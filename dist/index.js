(()=>{var __webpack_modules__={871:(e,t,r)=>{"use strict";var n;const o=r(622);function getPath(){if(process.env.USE_SYSTEM_7ZA==="true"){return"7za"}if(process.platform==="darwin"){return r.ab+"mac/"+process.arch+"//7za"}else if(process.platform==="win32"){return r.ab+"win/"+process.arch+"//7za.exe"}else{return r.ab+"linux/"+process.arch+"//7za"}}t.P=getPath();n=r.ab+"7x.sh"},400:(e,t,r)=>{"use strict";const n=r(129).spawn;const o=r(871).P;function unpack(e,t,r){if(typeof t==="function"&&r===undefined){r=t;run(o,["x",e,"-y"],r)}else{run(o,["x",e,"-y","-o"+t],r)}}function pack(e,t,r){run(o,["a",t,e],r)}function list(e,t){run(o,["l","-slt","-ba",e],t)}function cmd(e,t){run(o,e,t)}function run(e,t,r){r=onceify(r);const o=n(e,t);let a="";o.on("error",(function(e){r(e)}));o.on("exit",(function(e){let n=null;if(t[0]==="l"){n=parseListOutput(a)}r(e?new Error("Exited with code "+e):null,n)}));o.stdout.on("data",(e=>{a+=e.toString()}))}function onceify(e){let t=false;return function(){if(t)return;t=true;e.apply(this,Array.prototype.slice.call(arguments))}}function parseListOutput(e){if(!e.length)return[];e=e.replace(/(\r\n|\n|\r)/gm,"\n");const t=e.split(/^\s*$/m);const r=[];const n={Path:"name",Size:"size","Packed Size":"compressed",Attributes:"attr",Modified:"dateTime",CRC:"crc",Method:"method",Block:"block",Encrypted:"encrypted"};if(!t.length)return[];for(let e of t){if(!e.length)continue;const t={};const o=e.split("\n");if(!o.length)continue;for(let e of o){const r=e.split(" = ");if(r.length!==2)continue;const o=r[0].trim();const a=r[1].trim();if(n[o]){if(n[o]==="dateTime"){const e=a.split(" ");if(e.length!==2)continue;t["date"]=e[0];t["time"]=e[1]}else{t[n[o]]=a}}}if(Object.keys(t).length)r.push(t)}return r}t.unpack=unpack;t.pack=pack;t.list=list;t.cmd=cmd},241:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){if(n===undefined)n=r;Object.defineProperty(e,n,{enumerable:true,get:function(){return t[r]}})}:function(e,t,r,n){if(n===undefined)n=r;e[n]=t[r]});var o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:true,value:t})}:function(e,t){e["default"]=t});var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(e!=null)for(var r in e)if(r!=="default"&&Object.hasOwnProperty.call(e,r))n(t,e,r);o(t,e);return t};Object.defineProperty(t,"__esModule",{value:true});t.issue=t.issueCommand=void 0;const i=a(r(87));const l=r(278);function issueCommand(e,t,r){const n=new Command(e,t,r);process.stdout.write(n.toString()+i.EOL)}t.issueCommand=issueCommand;function issue(e,t=""){issueCommand(e,{},t)}t.issue=issue;const s="::";class Command{constructor(e,t,r){if(!e){e="missing.command"}this.command=e;this.properties=t;this.message=r}toString(){let e=s+this.command;if(this.properties&&Object.keys(this.properties).length>0){e+=" ";let t=true;for(const r in this.properties){if(this.properties.hasOwnProperty(r)){const n=this.properties[r];if(n){if(t){t=false}else{e+=","}e+=`${r}=${escapeProperty(n)}`}}}}e+=`${s}${escapeData(this.message)}`;return e}}function escapeData(e){return l.toCommandValue(e).replace(/%/g,"%25").replace(/\r/g,"%0D").replace(/\n/g,"%0A")}function escapeProperty(e){return l.toCommandValue(e).replace(/%/g,"%25").replace(/\r/g,"%0D").replace(/\n/g,"%0A").replace(/:/g,"%3A").replace(/,/g,"%2C")}},186:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){if(n===undefined)n=r;Object.defineProperty(e,n,{enumerable:true,get:function(){return t[r]}})}:function(e,t,r,n){if(n===undefined)n=r;e[n]=t[r]});var o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:true,value:t})}:function(e,t){e["default"]=t});var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(e!=null)for(var r in e)if(r!=="default"&&Object.hasOwnProperty.call(e,r))n(t,e,r);o(t,e);return t};var i=this&&this.__awaiter||function(e,t,r,n){function adopt(e){return e instanceof r?e:new r((function(t){t(e)}))}return new(r||(r=Promise))((function(r,o){function fulfilled(e){try{step(n.next(e))}catch(e){o(e)}}function rejected(e){try{step(n["throw"](e))}catch(e){o(e)}}function step(e){e.done?r(e.value):adopt(e.value).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:true});t.getState=t.saveState=t.group=t.endGroup=t.startGroup=t.info=t.notice=t.warning=t.error=t.debug=t.isDebug=t.setFailed=t.setCommandEcho=t.setOutput=t.getBooleanInput=t.getMultilineInput=t.getInput=t.addPath=t.setSecret=t.exportVariable=t.ExitCode=void 0;const l=r(241);const s=r(717);const u=r(278);const d=a(r(87));const c=a(r(622));var f;(function(e){e[e["Success"]=0]="Success";e[e["Failure"]=1]="Failure"})(f=t.ExitCode||(t.ExitCode={}));function exportVariable(e,t){const r=u.toCommandValue(t);process.env[e]=r;const n=process.env["GITHUB_ENV"]||"";if(n){const t="_GitHubActionsFileCommandDelimeter_";const n=`${e}<<${t}${d.EOL}${r}${d.EOL}${t}`;s.issueCommand("ENV",n)}else{l.issueCommand("set-env",{name:e},r)}}t.exportVariable=exportVariable;function setSecret(e){l.issueCommand("add-mask",{},e)}t.setSecret=setSecret;function addPath(e){const t=process.env["GITHUB_PATH"]||"";if(t){s.issueCommand("PATH",e)}else{l.issueCommand("add-path",{},e)}process.env["PATH"]=`${e}${c.delimiter}${process.env["PATH"]}`}t.addPath=addPath;function getInput(e,t){const r=process.env[`INPUT_${e.replace(/ /g,"_").toUpperCase()}`]||"";if(t&&t.required&&!r){throw new Error(`Input required and not supplied: ${e}`)}if(t&&t.trimWhitespace===false){return r}return r.trim()}t.getInput=getInput;function getMultilineInput(e,t){const r=getInput(e,t).split("\n").filter((e=>e!==""));return r}t.getMultilineInput=getMultilineInput;function getBooleanInput(e,t){const r=["true","True","TRUE"];const n=["false","False","FALSE"];const o=getInput(e,t);if(r.includes(o))return true;if(n.includes(o))return false;throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${e}\n`+`Support boolean input list: \`true | True | TRUE | false | False | FALSE\``)}t.getBooleanInput=getBooleanInput;function setOutput(e,t){process.stdout.write(d.EOL);l.issueCommand("set-output",{name:e},t)}t.setOutput=setOutput;function setCommandEcho(e){l.issue("echo",e?"on":"off")}t.setCommandEcho=setCommandEcho;function setFailed(e){process.exitCode=f.Failure;error(e)}t.setFailed=setFailed;function isDebug(){return process.env["RUNNER_DEBUG"]==="1"}t.isDebug=isDebug;function debug(e){l.issueCommand("debug",{},e)}t.debug=debug;function error(e,t={}){l.issueCommand("error",u.toCommandProperties(t),e instanceof Error?e.toString():e)}t.error=error;function warning(e,t={}){l.issueCommand("warning",u.toCommandProperties(t),e instanceof Error?e.toString():e)}t.warning=warning;function notice(e,t={}){l.issueCommand("notice",u.toCommandProperties(t),e instanceof Error?e.toString():e)}t.notice=notice;function info(e){process.stdout.write(e+d.EOL)}t.info=info;function startGroup(e){l.issue("group",e)}t.startGroup=startGroup;function endGroup(){l.issue("endgroup")}t.endGroup=endGroup;function group(e,t){return i(this,void 0,void 0,(function*(){startGroup(e);let r;try{r=yield t()}finally{endGroup()}return r}))}t.group=group;function saveState(e,t){l.issueCommand("save-state",{name:e},t)}t.saveState=saveState;function getState(e){return process.env[`STATE_${e}`]||""}t.getState=getState},717:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){if(n===undefined)n=r;Object.defineProperty(e,n,{enumerable:true,get:function(){return t[r]}})}:function(e,t,r,n){if(n===undefined)n=r;e[n]=t[r]});var o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:true,value:t})}:function(e,t){e["default"]=t});var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(e!=null)for(var r in e)if(r!=="default"&&Object.hasOwnProperty.call(e,r))n(t,e,r);o(t,e);return t};Object.defineProperty(t,"__esModule",{value:true});t.issueCommand=void 0;const i=a(r(747));const l=a(r(87));const s=r(278);function issueCommand(e,t){const r=process.env[`GITHUB_${e}`];if(!r){throw new Error(`Unable to find environment variable for file command ${e}`)}if(!i.existsSync(r)){throw new Error(`Missing file at path: ${r}`)}i.appendFileSync(r,`${s.toCommandValue(t)}${l.EOL}`,{encoding:"utf8"})}t.issueCommand=issueCommand},278:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:true});t.toCommandProperties=t.toCommandValue=void 0;function toCommandValue(e){if(e===null||e===undefined){return""}else if(typeof e==="string"||e instanceof String){return e}return JSON.stringify(e)}t.toCommandValue=toCommandValue;function toCommandProperties(e){if(!Object.keys(e).length){return{}}return{title:e.title,line:e.startLine,endLine:e.endLine,col:e.startColumn,endColumn:e.endColumn}}t.toCommandProperties=toCommandProperties},514:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){if(n===undefined)n=r;Object.defineProperty(e,n,{enumerable:true,get:function(){return t[r]}})}:function(e,t,r,n){if(n===undefined)n=r;e[n]=t[r]});var o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:true,value:t})}:function(e,t){e["default"]=t});var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(e!=null)for(var r in e)if(r!=="default"&&Object.hasOwnProperty.call(e,r))n(t,e,r);o(t,e);return t};var i=this&&this.__awaiter||function(e,t,r,n){function adopt(e){return e instanceof r?e:new r((function(t){t(e)}))}return new(r||(r=Promise))((function(r,o){function fulfilled(e){try{step(n.next(e))}catch(e){o(e)}}function rejected(e){try{step(n["throw"](e))}catch(e){o(e)}}function step(e){e.done?r(e.value):adopt(e.value).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:true});t.getExecOutput=t.exec=void 0;const l=r(304);const s=a(r(159));function exec(e,t,r){return i(this,void 0,void 0,(function*(){const n=s.argStringToArray(e);if(n.length===0){throw new Error(`Parameter 'commandLine' cannot be null or empty.`)}const o=n[0];t=n.slice(1).concat(t||[]);const a=new s.ToolRunner(o,t,r);return a.exec()}))}t.exec=exec;function getExecOutput(e,t,r){var n,o;return i(this,void 0,void 0,(function*(){let a="";let i="";const s=new l.StringDecoder("utf8");const u=new l.StringDecoder("utf8");const d=(n=r===null||r===void 0?void 0:r.listeners)===null||n===void 0?void 0:n.stdout;const c=(o=r===null||r===void 0?void 0:r.listeners)===null||o===void 0?void 0:o.stderr;const stdErrListener=e=>{i+=u.write(e);if(c){c(e)}};const stdOutListener=e=>{a+=s.write(e);if(d){d(e)}};const f=Object.assign(Object.assign({},r===null||r===void 0?void 0:r.listeners),{stdout:stdOutListener,stderr:stdErrListener});const m=yield exec(e,t,Object.assign(Object.assign({},r),{listeners:f}));a+=s.end();i+=u.end();return{exitCode:m,stdout:a,stderr:i}}))}t.getExecOutput=getExecOutput},159:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){if(n===undefined)n=r;Object.defineProperty(e,n,{enumerable:true,get:function(){return t[r]}})}:function(e,t,r,n){if(n===undefined)n=r;e[n]=t[r]});var o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:true,value:t})}:function(e,t){e["default"]=t});var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(e!=null)for(var r in e)if(r!=="default"&&Object.hasOwnProperty.call(e,r))n(t,e,r);o(t,e);return t};var i=this&&this.__awaiter||function(e,t,r,n){function adopt(e){return e instanceof r?e:new r((function(t){t(e)}))}return new(r||(r=Promise))((function(r,o){function fulfilled(e){try{step(n.next(e))}catch(e){o(e)}}function rejected(e){try{step(n["throw"](e))}catch(e){o(e)}}function step(e){e.done?r(e.value):adopt(e.value).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:true});t.argStringToArray=t.ToolRunner=void 0;const l=a(r(87));const s=a(r(614));const u=a(r(129));const d=a(r(622));const c=a(r(351));const f=a(r(962));const m=r(213);const h=process.platform==="win32";class ToolRunner extends s.EventEmitter{constructor(e,t,r){super();if(!e){throw new Error("Parameter 'toolPath' cannot be null or empty.")}this.toolPath=e;this.args=t||[];this.options=r||{}}_debug(e){if(this.options.listeners&&this.options.listeners.debug){this.options.listeners.debug(e)}}_getCommandString(e,t){const r=this._getSpawnFileName();const n=this._getSpawnArgs(e);let o=t?"":"[command]";if(h){if(this._isCmdFile()){o+=r;for(const e of n){o+=` ${e}`}}else if(e.windowsVerbatimArguments){o+=`"${r}"`;for(const e of n){o+=` ${e}`}}else{o+=this._windowsQuoteCmdArg(r);for(const e of n){o+=` ${this._windowsQuoteCmdArg(e)}`}}}else{o+=r;for(const e of n){o+=` ${e}`}}return o}_processLineBuffer(e,t,r){try{let n=t+e.toString();let o=n.indexOf(l.EOL);while(o>-1){const e=n.substring(0,o);r(e);n=n.substring(o+l.EOL.length);o=n.indexOf(l.EOL)}return n}catch(e){this._debug(`error processing line. Failed with error ${e}`);return""}}_getSpawnFileName(){if(h){if(this._isCmdFile()){return process.env["COMSPEC"]||"cmd.exe"}}return this.toolPath}_getSpawnArgs(e){if(h){if(this._isCmdFile()){let t=`/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;for(const r of this.args){t+=" ";t+=e.windowsVerbatimArguments?r:this._windowsQuoteCmdArg(r)}t+='"';return[t]}}return this.args}_endsWith(e,t){return e.endsWith(t)}_isCmdFile(){const e=this.toolPath.toUpperCase();return this._endsWith(e,".CMD")||this._endsWith(e,".BAT")}_windowsQuoteCmdArg(e){if(!this._isCmdFile()){return this._uvQuoteCmdArg(e)}if(!e){return'""'}const t=[" ","\t","&","(",")","[","]","{","}","^","=",";","!","'","+",",","`","~","|","<",">",'"'];let r=false;for(const n of e){if(t.some((e=>e===n))){r=true;break}}if(!r){return e}let n='"';let o=true;for(let t=e.length;t>0;t--){n+=e[t-1];if(o&&e[t-1]==="\\"){n+="\\"}else if(e[t-1]==='"'){o=true;n+='"'}else{o=false}}n+='"';return n.split("").reverse().join("")}_uvQuoteCmdArg(e){if(!e){return'""'}if(!e.includes(" ")&&!e.includes("\t")&&!e.includes('"')){return e}if(!e.includes('"')&&!e.includes("\\")){return`"${e}"`}let t='"';let r=true;for(let n=e.length;n>0;n--){t+=e[n-1];if(r&&e[n-1]==="\\"){t+="\\"}else if(e[n-1]==='"'){r=true;t+="\\"}else{r=false}}t+='"';return t.split("").reverse().join("")}_cloneExecOptions(e){e=e||{};const t={cwd:e.cwd||process.cwd(),env:e.env||process.env,silent:e.silent||false,windowsVerbatimArguments:e.windowsVerbatimArguments||false,failOnStdErr:e.failOnStdErr||false,ignoreReturnCode:e.ignoreReturnCode||false,delay:e.delay||1e4};t.outStream=e.outStream||process.stdout;t.errStream=e.errStream||process.stderr;return t}_getSpawnOptions(e,t){e=e||{};const r={};r.cwd=e.cwd;r.env=e.env;r["windowsVerbatimArguments"]=e.windowsVerbatimArguments||this._isCmdFile();if(e.windowsVerbatimArguments){r.argv0=`"${t}"`}return r}exec(){return i(this,void 0,void 0,(function*(){if(!f.isRooted(this.toolPath)&&(this.toolPath.includes("/")||h&&this.toolPath.includes("\\"))){this.toolPath=d.resolve(process.cwd(),this.options.cwd||process.cwd(),this.toolPath)}this.toolPath=yield c.which(this.toolPath,true);return new Promise(((e,t)=>i(this,void 0,void 0,(function*(){this._debug(`exec tool: ${this.toolPath}`);this._debug("arguments:");for(const e of this.args){this._debug(`   ${e}`)}const r=this._cloneExecOptions(this.options);if(!r.silent&&r.outStream){r.outStream.write(this._getCommandString(r)+l.EOL)}const n=new ExecState(r,this.toolPath);n.on("debug",(e=>{this._debug(e)}));if(this.options.cwd&&!(yield f.exists(this.options.cwd))){return t(new Error(`The cwd: ${this.options.cwd} does not exist!`))}const o=this._getSpawnFileName();const a=u.spawn(o,this._getSpawnArgs(r),this._getSpawnOptions(this.options,o));let i="";if(a.stdout){a.stdout.on("data",(e=>{if(this.options.listeners&&this.options.listeners.stdout){this.options.listeners.stdout(e)}if(!r.silent&&r.outStream){r.outStream.write(e)}i=this._processLineBuffer(e,i,(e=>{if(this.options.listeners&&this.options.listeners.stdline){this.options.listeners.stdline(e)}}))}))}let s="";if(a.stderr){a.stderr.on("data",(e=>{n.processStderr=true;if(this.options.listeners&&this.options.listeners.stderr){this.options.listeners.stderr(e)}if(!r.silent&&r.errStream&&r.outStream){const t=r.failOnStdErr?r.errStream:r.outStream;t.write(e)}s=this._processLineBuffer(e,s,(e=>{if(this.options.listeners&&this.options.listeners.errline){this.options.listeners.errline(e)}}))}))}a.on("error",(e=>{n.processError=e.message;n.processExited=true;n.processClosed=true;n.CheckComplete()}));a.on("exit",(e=>{n.processExitCode=e;n.processExited=true;this._debug(`Exit code ${e} received from tool '${this.toolPath}'`);n.CheckComplete()}));a.on("close",(e=>{n.processExitCode=e;n.processExited=true;n.processClosed=true;this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);n.CheckComplete()}));n.on("done",((r,n)=>{if(i.length>0){this.emit("stdline",i)}if(s.length>0){this.emit("errline",s)}a.removeAllListeners();if(r){t(r)}else{e(n)}}));if(this.options.input){if(!a.stdin){throw new Error("child process missing stdin")}a.stdin.end(this.options.input)}}))))}))}}t.ToolRunner=ToolRunner;function argStringToArray(e){const t=[];let r=false;let n=false;let o="";function append(e){if(n&&e!=='"'){o+="\\"}o+=e;n=false}for(let a=0;a<e.length;a++){const i=e.charAt(a);if(i==='"'){if(!n){r=!r}else{append(i)}continue}if(i==="\\"&&n){append(i);continue}if(i==="\\"&&r){n=true;continue}if(i===" "&&!r){if(o.length>0){t.push(o);o=""}continue}append(i)}if(o.length>0){t.push(o.trim())}return t}t.argStringToArray=argStringToArray;class ExecState extends s.EventEmitter{constructor(e,t){super();this.processClosed=false;this.processError="";this.processExitCode=0;this.processExited=false;this.processStderr=false;this.delay=1e4;this.done=false;this.timeout=null;if(!t){throw new Error("toolPath must not be empty")}this.options=e;this.toolPath=t;if(e.delay){this.delay=e.delay}}CheckComplete(){if(this.done){return}if(this.processClosed){this._setResult()}else if(this.processExited){this.timeout=m.setTimeout(ExecState.HandleTimeout,this.delay,this)}}_debug(e){this.emit("debug",e)}_setResult(){let e;if(this.processExited){if(this.processError){e=new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`)}else if(this.processExitCode!==0&&!this.options.ignoreReturnCode){e=new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`)}else if(this.processStderr&&this.options.failOnStdErr){e=new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`)}}if(this.timeout){clearTimeout(this.timeout);this.timeout=null}this.done=true;this.emit("done",e,this.processExitCode)}static HandleTimeout(e){if(e.done){return}if(!e.processClosed&&e.processExited){const t=`The STDIO streams did not close within ${e.delay/1e3} seconds of the exit event from process '${e.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;e._debug(t)}e._setResult()}}},962:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){if(n===undefined)n=r;Object.defineProperty(e,n,{enumerable:true,get:function(){return t[r]}})}:function(e,t,r,n){if(n===undefined)n=r;e[n]=t[r]});var o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:true,value:t})}:function(e,t){e["default"]=t});var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(e!=null)for(var r in e)if(r!=="default"&&Object.hasOwnProperty.call(e,r))n(t,e,r);o(t,e);return t};var i=this&&this.__awaiter||function(e,t,r,n){function adopt(e){return e instanceof r?e:new r((function(t){t(e)}))}return new(r||(r=Promise))((function(r,o){function fulfilled(e){try{step(n.next(e))}catch(e){o(e)}}function rejected(e){try{step(n["throw"](e))}catch(e){o(e)}}function step(e){e.done?r(e.value):adopt(e.value).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())}))};var l;Object.defineProperty(t,"__esModule",{value:true});t.getCmdPath=t.tryGetExecutablePath=t.isRooted=t.isDirectory=t.exists=t.IS_WINDOWS=t.unlink=t.symlink=t.stat=t.rmdir=t.rename=t.readlink=t.readdir=t.mkdir=t.lstat=t.copyFile=t.chmod=void 0;const s=a(r(747));const u=a(r(622));l=s.promises,t.chmod=l.chmod,t.copyFile=l.copyFile,t.lstat=l.lstat,t.mkdir=l.mkdir,t.readdir=l.readdir,t.readlink=l.readlink,t.rename=l.rename,t.rmdir=l.rmdir,t.stat=l.stat,t.symlink=l.symlink,t.unlink=l.unlink;t.IS_WINDOWS=process.platform==="win32";function exists(e){return i(this,void 0,void 0,(function*(){try{yield t.stat(e)}catch(e){if(e.code==="ENOENT"){return false}throw e}return true}))}t.exists=exists;function isDirectory(e,r=false){return i(this,void 0,void 0,(function*(){const n=r?yield t.stat(e):yield t.lstat(e);return n.isDirectory()}))}t.isDirectory=isDirectory;function isRooted(e){e=normalizeSeparators(e);if(!e){throw new Error('isRooted() parameter "p" cannot be empty')}if(t.IS_WINDOWS){return e.startsWith("\\")||/^[A-Z]:/i.test(e)}return e.startsWith("/")}t.isRooted=isRooted;function tryGetExecutablePath(e,r){return i(this,void 0,void 0,(function*(){let n=undefined;try{n=yield t.stat(e)}catch(t){if(t.code!=="ENOENT"){console.log(`Unexpected error attempting to determine if executable file exists '${e}': ${t}`)}}if(n&&n.isFile()){if(t.IS_WINDOWS){const t=u.extname(e).toUpperCase();if(r.some((e=>e.toUpperCase()===t))){return e}}else{if(isUnixExecutable(n)){return e}}}const o=e;for(const a of r){e=o+a;n=undefined;try{n=yield t.stat(e)}catch(t){if(t.code!=="ENOENT"){console.log(`Unexpected error attempting to determine if executable file exists '${e}': ${t}`)}}if(n&&n.isFile()){if(t.IS_WINDOWS){try{const r=u.dirname(e);const n=u.basename(e).toUpperCase();for(const o of yield t.readdir(r)){if(n===o.toUpperCase()){e=u.join(r,o);break}}}catch(t){console.log(`Unexpected error attempting to determine the actual case of the file '${e}': ${t}`)}return e}else{if(isUnixExecutable(n)){return e}}}}return""}))}t.tryGetExecutablePath=tryGetExecutablePath;function normalizeSeparators(e){e=e||"";if(t.IS_WINDOWS){e=e.replace(/\//g,"\\");return e.replace(/\\\\+/g,"\\")}return e.replace(/\/\/+/g,"/")}function isUnixExecutable(e){return(e.mode&1)>0||(e.mode&8)>0&&e.gid===process.getgid()||(e.mode&64)>0&&e.uid===process.getuid()}function getCmdPath(){var e;return(e=process.env["COMSPEC"])!==null&&e!==void 0?e:`cmd.exe`}t.getCmdPath=getCmdPath},351:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){if(n===undefined)n=r;Object.defineProperty(e,n,{enumerable:true,get:function(){return t[r]}})}:function(e,t,r,n){if(n===undefined)n=r;e[n]=t[r]});var o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:true,value:t})}:function(e,t){e["default"]=t});var a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(e!=null)for(var r in e)if(r!=="default"&&Object.hasOwnProperty.call(e,r))n(t,e,r);o(t,e);return t};var i=this&&this.__awaiter||function(e,t,r,n){function adopt(e){return e instanceof r?e:new r((function(t){t(e)}))}return new(r||(r=Promise))((function(r,o){function fulfilled(e){try{step(n.next(e))}catch(e){o(e)}}function rejected(e){try{step(n["throw"](e))}catch(e){o(e)}}function step(e){e.done?r(e.value):adopt(e.value).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:true});t.findInPath=t.which=t.mkdirP=t.rmRF=t.mv=t.cp=void 0;const l=r(357);const s=a(r(129));const u=a(r(622));const d=r(669);const c=a(r(962));const f=d.promisify(s.exec);const m=d.promisify(s.execFile);function cp(e,t,r={}){return i(this,void 0,void 0,(function*(){const{force:n,recursive:o,copySourceDirectory:a}=readCopyOptions(r);const i=(yield c.exists(t))?yield c.stat(t):null;if(i&&i.isFile()&&!n){return}const l=i&&i.isDirectory()&&a?u.join(t,u.basename(e)):t;if(!(yield c.exists(e))){throw new Error(`no such file or directory: ${e}`)}const s=yield c.stat(e);if(s.isDirectory()){if(!o){throw new Error(`Failed to copy. ${e} is a directory, but tried to copy without recursive flag.`)}else{yield cpDirRecursive(e,l,0,n)}}else{if(u.relative(e,l)===""){throw new Error(`'${l}' and '${e}' are the same file`)}yield copyFile(e,l,n)}}))}t.cp=cp;function mv(e,t,r={}){return i(this,void 0,void 0,(function*(){if(yield c.exists(t)){let n=true;if(yield c.isDirectory(t)){t=u.join(t,u.basename(e));n=yield c.exists(t)}if(n){if(r.force==null||r.force){yield rmRF(t)}else{throw new Error("Destination already exists")}}}yield mkdirP(u.dirname(t));yield c.rename(e,t)}))}t.mv=mv;function rmRF(e){return i(this,void 0,void 0,(function*(){if(c.IS_WINDOWS){if(/[*"<>|]/.test(e)){throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows')}try{const t=c.getCmdPath();if(yield c.isDirectory(e,true)){yield f(`${t} /s /c "rd /s /q "%inputPath%""`,{env:{inputPath:e}})}else{yield f(`${t} /s /c "del /f /a "%inputPath%""`,{env:{inputPath:e}})}}catch(e){if(e.code!=="ENOENT")throw e}try{yield c.unlink(e)}catch(e){if(e.code!=="ENOENT")throw e}}else{let t=false;try{t=yield c.isDirectory(e)}catch(e){if(e.code!=="ENOENT")throw e;return}if(t){yield m(`rm`,[`-rf`,`${e}`])}else{yield c.unlink(e)}}}))}t.rmRF=rmRF;function mkdirP(e){return i(this,void 0,void 0,(function*(){l.ok(e,"a path argument must be provided");yield c.mkdir(e,{recursive:true})}))}t.mkdirP=mkdirP;function which(e,t){return i(this,void 0,void 0,(function*(){if(!e){throw new Error("parameter 'tool' is required")}if(t){const t=yield which(e,false);if(!t){if(c.IS_WINDOWS){throw new Error(`Unable to locate executable file: ${e}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`)}else{throw new Error(`Unable to locate executable file: ${e}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`)}}return t}const r=yield findInPath(e);if(r&&r.length>0){return r[0]}return""}))}t.which=which;function findInPath(e){return i(this,void 0,void 0,(function*(){if(!e){throw new Error("parameter 'tool' is required")}const t=[];if(c.IS_WINDOWS&&process.env["PATHEXT"]){for(const e of process.env["PATHEXT"].split(u.delimiter)){if(e){t.push(e)}}}if(c.isRooted(e)){const r=yield c.tryGetExecutablePath(e,t);if(r){return[r]}return[]}if(e.includes(u.sep)){return[]}const r=[];if(process.env.PATH){for(const e of process.env.PATH.split(u.delimiter)){if(e){r.push(e)}}}const n=[];for(const o of r){const r=yield c.tryGetExecutablePath(u.join(o,e),t);if(r){n.push(r)}}return n}))}t.findInPath=findInPath;function readCopyOptions(e){const t=e.force==null?true:e.force;const r=Boolean(e.recursive);const n=e.copySourceDirectory==null?true:Boolean(e.copySourceDirectory);return{force:t,recursive:r,copySourceDirectory:n}}function cpDirRecursive(e,t,r,n){return i(this,void 0,void 0,(function*(){if(r>=255)return;r++;yield mkdirP(t);const o=yield c.readdir(e);for(const a of o){const o=`${e}/${a}`;const i=`${t}/${a}`;const l=yield c.lstat(o);if(l.isDirectory()){yield cpDirRecursive(o,i,r,n)}else{yield copyFile(o,i,n)}}yield c.chmod(t,(yield c.stat(e)).mode)}))}function copyFile(e,t,r){return i(this,void 0,void 0,(function*(){if((yield c.lstat(e)).isSymbolicLink()){try{yield c.lstat(t);yield c.unlink(t)}catch(e){if(e.code==="EPERM"){yield c.chmod(t,"0666");yield c.unlink(t)}}const r=yield c.readlink(e);yield c.symlink(r,t,c.IS_WINDOWS?"junction":null)}else if(!(yield c.exists(t))||r){yield c.copyFile(e,t)}}))}},371:e=>{"use strict";function dataUriToBuffer(e){if(!/^data:/i.test(e)){throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")')}e=e.replace(/\r?\n/g,"");const t=e.indexOf(",");if(t===-1||t<=4){throw new TypeError("malformed data: URI")}const r=e.substring(5,t).split(";");let n="";let o=false;const a=r[0]||"text/plain";let i=a;for(let e=1;e<r.length;e++){if(r[e]==="base64"){o=true}else{i+=`;${r[e]}`;if(r[e].indexOf("charset=")===0){n=r[e].substring(8)}}}if(!r[0]&&!n.length){i+=";charset=US-ASCII";n="US-ASCII"}const l=o?"base64":"ascii";const s=unescape(e.substring(t+1));const u=Buffer.from(s,l);u.type=a;u.typeFull=i;u.charset=n;return u}e.exports=dataUriToBuffer},452:function(e,t){(function(e,r){true?r(t):0})(this,(function(e){"use strict";const t=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?Symbol:e=>`Symbol(${e})`;function noop(){return undefined}function getGlobals(){if(typeof self!=="undefined"){return self}else if(typeof window!=="undefined"){return window}else if(typeof global!=="undefined"){return global}return undefined}const r=getGlobals();function typeIsObject(e){return typeof e==="object"&&e!==null||typeof e==="function"}const n=noop;const o=Promise;const a=Promise.prototype.then;const i=Promise.resolve.bind(o);const l=Promise.reject.bind(o);function newPromise(e){return new o(e)}function promiseResolvedWith(e){return i(e)}function promiseRejectedWith(e){return l(e)}function PerformPromiseThen(e,t,r){return a.call(e,t,r)}function uponPromise(e,t,r){PerformPromiseThen(PerformPromiseThen(e,t,r),undefined,n)}function uponFulfillment(e,t){uponPromise(e,t)}function uponRejection(e,t){uponPromise(e,undefined,t)}function transformPromiseWith(e,t,r){return PerformPromiseThen(e,t,r)}function setPromiseIsHandledToTrue(e){PerformPromiseThen(e,undefined,n)}const s=(()=>{const e=r&&r.queueMicrotask;if(typeof e==="function"){return e}const t=promiseResolvedWith(undefined);return e=>PerformPromiseThen(t,e)})();function reflectCall(e,t,r){if(typeof e!=="function"){throw new TypeError("Argument is not a function")}return Function.prototype.apply.call(e,t,r)}function promiseCall(e,t,r){try{return promiseResolvedWith(reflectCall(e,t,r))}catch(e){return promiseRejectedWith(e)}}const u=16384;class SimpleQueue{constructor(){this._cursor=0;this._size=0;this._front={_elements:[],_next:undefined};this._back=this._front;this._cursor=0;this._size=0}get length(){return this._size}push(e){const t=this._back;let r=t;if(t._elements.length===u-1){r={_elements:[],_next:undefined}}t._elements.push(e);if(r!==t){this._back=r;t._next=r}++this._size}shift(){const e=this._front;let t=e;const r=this._cursor;let n=r+1;const o=e._elements;const a=o[r];if(n===u){t=e._next;n=0}--this._size;this._cursor=n;if(e!==t){this._front=t}o[r]=undefined;return a}forEach(e){let t=this._cursor;let r=this._front;let n=r._elements;while(t!==n.length||r._next!==undefined){if(t===n.length){r=r._next;n=r._elements;t=0;if(n.length===0){break}}e(n[t]);++t}}peek(){const e=this._front;const t=this._cursor;return e._elements[t]}}function ReadableStreamReaderGenericInitialize(e,t){e._ownerReadableStream=t;t._reader=e;if(t._state==="readable"){defaultReaderClosedPromiseInitialize(e)}else if(t._state==="closed"){defaultReaderClosedPromiseInitializeAsResolved(e)}else{defaultReaderClosedPromiseInitializeAsRejected(e,t._storedError)}}function ReadableStreamReaderGenericCancel(e,t){const r=e._ownerReadableStream;return ReadableStreamCancel(r,t)}function ReadableStreamReaderGenericRelease(e){if(e._ownerReadableStream._state==="readable"){defaultReaderClosedPromiseReject(e,new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`))}else{defaultReaderClosedPromiseResetToRejected(e,new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`))}e._ownerReadableStream._reader=undefined;e._ownerReadableStream=undefined}function readerLockException(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function defaultReaderClosedPromiseInitialize(e){e._closedPromise=newPromise(((t,r)=>{e._closedPromise_resolve=t;e._closedPromise_reject=r}))}function defaultReaderClosedPromiseInitializeAsRejected(e,t){defaultReaderClosedPromiseInitialize(e);defaultReaderClosedPromiseReject(e,t)}function defaultReaderClosedPromiseInitializeAsResolved(e){defaultReaderClosedPromiseInitialize(e);defaultReaderClosedPromiseResolve(e)}function defaultReaderClosedPromiseReject(e,t){if(e._closedPromise_reject===undefined){return}setPromiseIsHandledToTrue(e._closedPromise);e._closedPromise_reject(t);e._closedPromise_resolve=undefined;e._closedPromise_reject=undefined}function defaultReaderClosedPromiseResetToRejected(e,t){defaultReaderClosedPromiseInitializeAsRejected(e,t)}function defaultReaderClosedPromiseResolve(e){if(e._closedPromise_resolve===undefined){return}e._closedPromise_resolve(undefined);e._closedPromise_resolve=undefined;e._closedPromise_reject=undefined}const d=t("[[AbortSteps]]");const c=t("[[ErrorSteps]]");const f=t("[[CancelSteps]]");const m=t("[[PullSteps]]");const h=Number.isFinite||function(e){return typeof e==="number"&&isFinite(e)};const b=Math.trunc||function(e){return e<0?Math.ceil(e):Math.floor(e)};function isDictionary(e){return typeof e==="object"||typeof e==="function"}function assertDictionary(e,t){if(e!==undefined&&!isDictionary(e)){throw new TypeError(`${t} is not an object.`)}}function assertFunction(e,t){if(typeof e!=="function"){throw new TypeError(`${t} is not a function.`)}}function isObject(e){return typeof e==="object"&&e!==null||typeof e==="function"}function assertObject(e,t){if(!isObject(e)){throw new TypeError(`${t} is not an object.`)}}function assertRequiredArgument(e,t,r){if(e===undefined){throw new TypeError(`Parameter ${t} is required in '${r}'.`)}}function assertRequiredField(e,t,r){if(e===undefined){throw new TypeError(`${t} is required in '${r}'.`)}}function convertUnrestrictedDouble(e){return Number(e)}function censorNegativeZero(e){return e===0?0:e}function integerPart(e){return censorNegativeZero(b(e))}function convertUnsignedLongLongWithEnforceRange(e,t){const r=0;const n=Number.MAX_SAFE_INTEGER;let o=Number(e);o=censorNegativeZero(o);if(!h(o)){throw new TypeError(`${t} is not a finite number`)}o=integerPart(o);if(o<r||o>n){throw new TypeError(`${t} is outside the accepted range of ${r} to ${n}, inclusive`)}if(!h(o)||o===0){return 0}return o}function assertReadableStream(e,t){if(!IsReadableStream(e)){throw new TypeError(`${t} is not a ReadableStream.`)}}function AcquireReadableStreamDefaultReader(e){return new ReadableStreamDefaultReader(e)}function ReadableStreamAddReadRequest(e,t){e._reader._readRequests.push(t)}function ReadableStreamFulfillReadRequest(e,t,r){const n=e._reader;const o=n._readRequests.shift();if(r){o._closeSteps()}else{o._chunkSteps(t)}}function ReadableStreamGetNumReadRequests(e){return e._reader._readRequests.length}function ReadableStreamHasDefaultReader(e){const t=e._reader;if(t===undefined){return false}if(!IsReadableStreamDefaultReader(t)){return false}return true}class ReadableStreamDefaultReader{constructor(e){assertRequiredArgument(e,1,"ReadableStreamDefaultReader");assertReadableStream(e,"First parameter");if(IsReadableStreamLocked(e)){throw new TypeError("This stream has already been locked for exclusive reading by another reader")}ReadableStreamReaderGenericInitialize(this,e);this._readRequests=new SimpleQueue}get closed(){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("closed"))}return this._closedPromise}cancel(e=undefined){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("cancel"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("cancel"))}return ReadableStreamReaderGenericCancel(this,e)}read(){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("read"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("read from"))}let e;let t;const r=newPromise(((r,n)=>{e=r;t=n}));const n={_chunkSteps:t=>e({value:t,done:false}),_closeSteps:()=>e({value:undefined,done:true}),_errorSteps:e=>t(e)};ReadableStreamDefaultReaderRead(this,n);return r}releaseLock(){if(!IsReadableStreamDefaultReader(this)){throw defaultReaderBrandCheckException("releaseLock")}if(this._ownerReadableStream===undefined){return}if(this._readRequests.length>0){throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled")}ReadableStreamReaderGenericRelease(this)}}Object.defineProperties(ReadableStreamDefaultReader.prototype,{cancel:{enumerable:true},read:{enumerable:true},releaseLock:{enumerable:true},closed:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamDefaultReader.prototype,t.toStringTag,{value:"ReadableStreamDefaultReader",configurable:true})}function IsReadableStreamDefaultReader(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_readRequests")){return false}return e instanceof ReadableStreamDefaultReader}function ReadableStreamDefaultReaderRead(e,t){const r=e._ownerReadableStream;r._disturbed=true;if(r._state==="closed"){t._closeSteps()}else if(r._state==="errored"){t._errorSteps(r._storedError)}else{r._readableStreamController[m](t)}}function defaultReaderBrandCheckException(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}const p=Object.getPrototypeOf(Object.getPrototypeOf((async function*(){})).prototype);class ReadableStreamAsyncIteratorImpl{constructor(e,t){this._ongoingPromise=undefined;this._isFinished=false;this._reader=e;this._preventCancel=t}next(){const nextSteps=()=>this._nextSteps();this._ongoingPromise=this._ongoingPromise?transformPromiseWith(this._ongoingPromise,nextSteps,nextSteps):nextSteps();return this._ongoingPromise}return(e){const returnSteps=()=>this._returnSteps(e);return this._ongoingPromise?transformPromiseWith(this._ongoingPromise,returnSteps,returnSteps):returnSteps()}_nextSteps(){if(this._isFinished){return Promise.resolve({value:undefined,done:true})}const e=this._reader;if(e._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("iterate"))}let t;let r;const n=newPromise(((e,n)=>{t=e;r=n}));const o={_chunkSteps:e=>{this._ongoingPromise=undefined;s((()=>t({value:e,done:false})))},_closeSteps:()=>{this._ongoingPromise=undefined;this._isFinished=true;ReadableStreamReaderGenericRelease(e);t({value:undefined,done:true})},_errorSteps:t=>{this._ongoingPromise=undefined;this._isFinished=true;ReadableStreamReaderGenericRelease(e);r(t)}};ReadableStreamDefaultReaderRead(e,o);return n}_returnSteps(e){if(this._isFinished){return Promise.resolve({value:e,done:true})}this._isFinished=true;const t=this._reader;if(t._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("finish iterating"))}if(!this._preventCancel){const r=ReadableStreamReaderGenericCancel(t,e);ReadableStreamReaderGenericRelease(t);return transformPromiseWith(r,(()=>({value:e,done:true})))}ReadableStreamReaderGenericRelease(t);return promiseResolvedWith({value:e,done:true})}}const S={next(){if(!IsReadableStreamAsyncIterator(this)){return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"))}return this._asyncIteratorImpl.next()},return(e){if(!IsReadableStreamAsyncIterator(this)){return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"))}return this._asyncIteratorImpl.return(e)}};if(p!==undefined){Object.setPrototypeOf(S,p)}function AcquireReadableStreamAsyncIterator(e,t){const r=AcquireReadableStreamDefaultReader(e);const n=new ReadableStreamAsyncIteratorImpl(r,t);const o=Object.create(S);o._asyncIteratorImpl=n;return o}function IsReadableStreamAsyncIterator(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_asyncIteratorImpl")){return false}try{return e._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl}catch(e){return false}}function streamAsyncIteratorBrandCheckException(e){return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`)}const y=Number.isNaN||function(e){return e!==e};function CreateArrayFromList(e){return e.slice()}function CopyDataBlockBytes(e,t,r,n,o){new Uint8Array(e).set(new Uint8Array(r,n,o),t)}function TransferArrayBuffer(e){return e}function IsDetachedBuffer(e){return false}function ArrayBufferSlice(e,t,r){if(e.slice){return e.slice(t,r)}const n=r-t;const o=new ArrayBuffer(n);CopyDataBlockBytes(o,0,e,t,n);return o}function IsNonNegativeNumber(e){if(typeof e!=="number"){return false}if(y(e)){return false}if(e<0){return false}return true}function CloneAsUint8Array(e){const t=ArrayBufferSlice(e.buffer,e.byteOffset,e.byteOffset+e.byteLength);return new Uint8Array(t)}function DequeueValue(e){const t=e._queue.shift();e._queueTotalSize-=t.size;if(e._queueTotalSize<0){e._queueTotalSize=0}return t.value}function EnqueueValueWithSize(e,t,r){if(!IsNonNegativeNumber(r)||r===Infinity){throw new RangeError("Size must be a finite, non-NaN, non-negative number.")}e._queue.push({value:t,size:r});e._queueTotalSize+=r}function PeekQueueValue(e){const t=e._queue.peek();return t.value}function ResetQueue(e){e._queue=new SimpleQueue;e._queueTotalSize=0}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("view")}return this._view}respond(e){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("respond")}assertRequiredArgument(e,1,"respond");e=convertUnsignedLongLongWithEnforceRange(e,"First parameter");if(this._associatedReadableByteStreamController===undefined){throw new TypeError("This BYOB request has been invalidated")}if(IsDetachedBuffer(this._view.buffer));ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("respondWithNewView")}assertRequiredArgument(e,1,"respondWithNewView");if(!ArrayBuffer.isView(e)){throw new TypeError("You can only respond with array buffer views")}if(this._associatedReadableByteStreamController===undefined){throw new TypeError("This BYOB request has been invalidated")}if(IsDetachedBuffer(e.buffer));ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController,e)}}Object.defineProperties(ReadableStreamBYOBRequest.prototype,{respond:{enumerable:true},respondWithNewView:{enumerable:true},view:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamBYOBRequest.prototype,t.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:true})}class ReadableByteStreamController{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("byobRequest")}return ReadableByteStreamControllerGetBYOBRequest(this)}get desiredSize(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("desiredSize")}return ReadableByteStreamControllerGetDesiredSize(this)}close(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("close")}if(this._closeRequested){throw new TypeError("The stream has already been closed; do not close it again!")}const e=this._controlledReadableByteStream._state;if(e!=="readable"){throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`)}ReadableByteStreamControllerClose(this)}enqueue(e){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("enqueue")}assertRequiredArgument(e,1,"enqueue");if(!ArrayBuffer.isView(e)){throw new TypeError("chunk must be an array buffer view")}if(e.byteLength===0){throw new TypeError("chunk must have non-zero byteLength")}if(e.buffer.byteLength===0){throw new TypeError(`chunk's buffer must have non-zero byteLength`)}if(this._closeRequested){throw new TypeError("stream is closed or draining")}const t=this._controlledReadableByteStream._state;if(t!=="readable"){throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`)}ReadableByteStreamControllerEnqueue(this,e)}error(e=undefined){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("error")}ReadableByteStreamControllerError(this,e)}[f](e){ReadableByteStreamControllerClearPendingPullIntos(this);ResetQueue(this);const t=this._cancelAlgorithm(e);ReadableByteStreamControllerClearAlgorithms(this);return t}[m](e){const t=this._controlledReadableByteStream;if(this._queueTotalSize>0){const t=this._queue.shift();this._queueTotalSize-=t.byteLength;ReadableByteStreamControllerHandleQueueDrain(this);const r=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);e._chunkSteps(r);return}const r=this._autoAllocateChunkSize;if(r!==undefined){let t;try{t=new ArrayBuffer(r)}catch(t){e._errorSteps(t);return}const n={buffer:t,bufferByteLength:r,byteOffset:0,byteLength:r,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(n)}ReadableStreamAddReadRequest(t,e);ReadableByteStreamControllerCallPullIfNeeded(this)}}Object.defineProperties(ReadableByteStreamController.prototype,{close:{enumerable:true},enqueue:{enumerable:true},error:{enumerable:true},byobRequest:{enumerable:true},desiredSize:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableByteStreamController.prototype,t.toStringTag,{value:"ReadableByteStreamController",configurable:true})}function IsReadableByteStreamController(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")){return false}return e instanceof ReadableByteStreamController}function IsReadableStreamBYOBRequest(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")){return false}return e instanceof ReadableStreamBYOBRequest}function ReadableByteStreamControllerCallPullIfNeeded(e){const t=ReadableByteStreamControllerShouldCallPull(e);if(!t){return}if(e._pulling){e._pullAgain=true;return}e._pulling=true;const r=e._pullAlgorithm();uponPromise(r,(()=>{e._pulling=false;if(e._pullAgain){e._pullAgain=false;ReadableByteStreamControllerCallPullIfNeeded(e)}}),(t=>{ReadableByteStreamControllerError(e,t)}))}function ReadableByteStreamControllerClearPendingPullIntos(e){ReadableByteStreamControllerInvalidateBYOBRequest(e);e._pendingPullIntos=new SimpleQueue}function ReadableByteStreamControllerCommitPullIntoDescriptor(e,t){let r=false;if(e._state==="closed"){r=true}const n=ReadableByteStreamControllerConvertPullIntoDescriptor(t);if(t.readerType==="default"){ReadableStreamFulfillReadRequest(e,n,r)}else{ReadableStreamFulfillReadIntoRequest(e,n,r)}}function ReadableByteStreamControllerConvertPullIntoDescriptor(e){const t=e.bytesFilled;const r=e.elementSize;return new e.viewConstructor(e.buffer,e.byteOffset,t/r)}function ReadableByteStreamControllerEnqueueChunkToQueue(e,t,r,n){e._queue.push({buffer:t,byteOffset:r,byteLength:n});e._queueTotalSize+=n}function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(e,t){const r=t.elementSize;const n=t.bytesFilled-t.bytesFilled%r;const o=Math.min(e._queueTotalSize,t.byteLength-t.bytesFilled);const a=t.bytesFilled+o;const i=a-a%r;let l=o;let s=false;if(i>n){l=i-t.bytesFilled;s=true}const u=e._queue;while(l>0){const r=u.peek();const n=Math.min(l,r.byteLength);const o=t.byteOffset+t.bytesFilled;CopyDataBlockBytes(t.buffer,o,r.buffer,r.byteOffset,n);if(r.byteLength===n){u.shift()}else{r.byteOffset+=n;r.byteLength-=n}e._queueTotalSize-=n;ReadableByteStreamControllerFillHeadPullIntoDescriptor(e,n,t);l-=n}return s}function ReadableByteStreamControllerFillHeadPullIntoDescriptor(e,t,r){r.bytesFilled+=t}function ReadableByteStreamControllerHandleQueueDrain(e){if(e._queueTotalSize===0&&e._closeRequested){ReadableByteStreamControllerClearAlgorithms(e);ReadableStreamClose(e._controlledReadableByteStream)}else{ReadableByteStreamControllerCallPullIfNeeded(e)}}function ReadableByteStreamControllerInvalidateBYOBRequest(e){if(e._byobRequest===null){return}e._byobRequest._associatedReadableByteStreamController=undefined;e._byobRequest._view=null;e._byobRequest=null}function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(e){while(e._pendingPullIntos.length>0){if(e._queueTotalSize===0){return}const t=e._pendingPullIntos.peek();if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(e,t)){ReadableByteStreamControllerShiftPendingPullInto(e);ReadableByteStreamControllerCommitPullIntoDescriptor(e._controlledReadableByteStream,t)}}}function ReadableByteStreamControllerPullInto(e,t,r){const n=e._controlledReadableByteStream;let o=1;if(t.constructor!==DataView){o=t.constructor.BYTES_PER_ELEMENT}const a=t.constructor;const i=TransferArrayBuffer(t.buffer);const l={buffer:i,bufferByteLength:i.byteLength,byteOffset:t.byteOffset,byteLength:t.byteLength,bytesFilled:0,elementSize:o,viewConstructor:a,readerType:"byob"};if(e._pendingPullIntos.length>0){e._pendingPullIntos.push(l);ReadableStreamAddReadIntoRequest(n,r);return}if(n._state==="closed"){const e=new a(l.buffer,l.byteOffset,0);r._closeSteps(e);return}if(e._queueTotalSize>0){if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(e,l)){const t=ReadableByteStreamControllerConvertPullIntoDescriptor(l);ReadableByteStreamControllerHandleQueueDrain(e);r._chunkSteps(t);return}if(e._closeRequested){const t=new TypeError("Insufficient bytes to fill elements in the given buffer");ReadableByteStreamControllerError(e,t);r._errorSteps(t);return}}e._pendingPullIntos.push(l);ReadableStreamAddReadIntoRequest(n,r);ReadableByteStreamControllerCallPullIfNeeded(e)}function ReadableByteStreamControllerRespondInClosedState(e,t){const r=e._controlledReadableByteStream;if(ReadableStreamHasBYOBReader(r)){while(ReadableStreamGetNumReadIntoRequests(r)>0){const t=ReadableByteStreamControllerShiftPendingPullInto(e);ReadableByteStreamControllerCommitPullIntoDescriptor(r,t)}}}function ReadableByteStreamControllerRespondInReadableState(e,t,r){ReadableByteStreamControllerFillHeadPullIntoDescriptor(e,t,r);if(r.bytesFilled<r.elementSize){return}ReadableByteStreamControllerShiftPendingPullInto(e);const n=r.bytesFilled%r.elementSize;if(n>0){const t=r.byteOffset+r.bytesFilled;const o=ArrayBufferSlice(r.buffer,t-n,t);ReadableByteStreamControllerEnqueueChunkToQueue(e,o,0,o.byteLength)}r.bytesFilled-=n;ReadableByteStreamControllerCommitPullIntoDescriptor(e._controlledReadableByteStream,r);ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(e)}function ReadableByteStreamControllerRespondInternal(e,t){const r=e._pendingPullIntos.peek();ReadableByteStreamControllerInvalidateBYOBRequest(e);const n=e._controlledReadableByteStream._state;if(n==="closed"){ReadableByteStreamControllerRespondInClosedState(e)}else{ReadableByteStreamControllerRespondInReadableState(e,t,r)}ReadableByteStreamControllerCallPullIfNeeded(e)}function ReadableByteStreamControllerShiftPendingPullInto(e){const t=e._pendingPullIntos.shift();return t}function ReadableByteStreamControllerShouldCallPull(e){const t=e._controlledReadableByteStream;if(t._state!=="readable"){return false}if(e._closeRequested){return false}if(!e._started){return false}if(ReadableStreamHasDefaultReader(t)&&ReadableStreamGetNumReadRequests(t)>0){return true}if(ReadableStreamHasBYOBReader(t)&&ReadableStreamGetNumReadIntoRequests(t)>0){return true}const r=ReadableByteStreamControllerGetDesiredSize(e);if(r>0){return true}return false}function ReadableByteStreamControllerClearAlgorithms(e){e._pullAlgorithm=undefined;e._cancelAlgorithm=undefined}function ReadableByteStreamControllerClose(e){const t=e._controlledReadableByteStream;if(e._closeRequested||t._state!=="readable"){return}if(e._queueTotalSize>0){e._closeRequested=true;return}if(e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek();if(t.bytesFilled>0){const t=new TypeError("Insufficient bytes to fill elements in the given buffer");ReadableByteStreamControllerError(e,t);throw t}}ReadableByteStreamControllerClearAlgorithms(e);ReadableStreamClose(t)}function ReadableByteStreamControllerEnqueue(e,t){const r=e._controlledReadableByteStream;if(e._closeRequested||r._state!=="readable"){return}const n=t.buffer;const o=t.byteOffset;const a=t.byteLength;const i=TransferArrayBuffer(n);if(e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek();if(IsDetachedBuffer(t.buffer));t.buffer=TransferArrayBuffer(t.buffer)}ReadableByteStreamControllerInvalidateBYOBRequest(e);if(ReadableStreamHasDefaultReader(r)){if(ReadableStreamGetNumReadRequests(r)===0){ReadableByteStreamControllerEnqueueChunkToQueue(e,i,o,a)}else{const e=new Uint8Array(i,o,a);ReadableStreamFulfillReadRequest(r,e,false)}}else if(ReadableStreamHasBYOBReader(r)){ReadableByteStreamControllerEnqueueChunkToQueue(e,i,o,a);ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(e)}else{ReadableByteStreamControllerEnqueueChunkToQueue(e,i,o,a)}ReadableByteStreamControllerCallPullIfNeeded(e)}function ReadableByteStreamControllerError(e,t){const r=e._controlledReadableByteStream;if(r._state!=="readable"){return}ReadableByteStreamControllerClearPendingPullIntos(e);ResetQueue(e);ReadableByteStreamControllerClearAlgorithms(e);ReadableStreamError(r,t)}function ReadableByteStreamControllerGetBYOBRequest(e){if(e._byobRequest===null&&e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek();const r=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled);const n=Object.create(ReadableStreamBYOBRequest.prototype);SetUpReadableStreamBYOBRequest(n,e,r);e._byobRequest=n}return e._byobRequest}function ReadableByteStreamControllerGetDesiredSize(e){const t=e._controlledReadableByteStream._state;if(t==="errored"){return null}if(t==="closed"){return 0}return e._strategyHWM-e._queueTotalSize}function ReadableByteStreamControllerRespond(e,t){const r=e._pendingPullIntos.peek();const n=e._controlledReadableByteStream._state;if(n==="closed"){if(t!==0){throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}}else{if(t===0){throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream")}if(r.bytesFilled+t>r.byteLength){throw new RangeError("bytesWritten out of range")}}r.buffer=TransferArrayBuffer(r.buffer);ReadableByteStreamControllerRespondInternal(e,t)}function ReadableByteStreamControllerRespondWithNewView(e,t){const r=e._pendingPullIntos.peek();const n=e._controlledReadableByteStream._state;if(n==="closed"){if(t.byteLength!==0){throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}}else{if(t.byteLength===0){throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream")}}if(r.byteOffset+r.bytesFilled!==t.byteOffset){throw new RangeError("The region specified by view does not match byobRequest")}if(r.bufferByteLength!==t.buffer.byteLength){throw new RangeError("The buffer of view has different capacity than byobRequest")}if(r.bytesFilled+t.byteLength>r.byteLength){throw new RangeError("The region specified by view is larger than byobRequest")}r.buffer=TransferArrayBuffer(t.buffer);ReadableByteStreamControllerRespondInternal(e,t.byteLength)}function SetUpReadableByteStreamController(e,t,r,n,o,a,i){t._controlledReadableByteStream=e;t._pullAgain=false;t._pulling=false;t._byobRequest=null;t._queue=t._queueTotalSize=undefined;ResetQueue(t);t._closeRequested=false;t._started=false;t._strategyHWM=a;t._pullAlgorithm=n;t._cancelAlgorithm=o;t._autoAllocateChunkSize=i;t._pendingPullIntos=new SimpleQueue;e._readableStreamController=t;const l=r();uponPromise(promiseResolvedWith(l),(()=>{t._started=true;ReadableByteStreamControllerCallPullIfNeeded(t)}),(e=>{ReadableByteStreamControllerError(t,e)}))}function SetUpReadableByteStreamControllerFromUnderlyingSource(e,t,r){const n=Object.create(ReadableByteStreamController.prototype);let startAlgorithm=()=>undefined;let pullAlgorithm=()=>promiseResolvedWith(undefined);let cancelAlgorithm=()=>promiseResolvedWith(undefined);if(t.start!==undefined){startAlgorithm=()=>t.start(n)}if(t.pull!==undefined){pullAlgorithm=()=>t.pull(n)}if(t.cancel!==undefined){cancelAlgorithm=e=>t.cancel(e)}const o=t.autoAllocateChunkSize;if(o===0){throw new TypeError("autoAllocateChunkSize must be greater than 0")}SetUpReadableByteStreamController(e,n,startAlgorithm,pullAlgorithm,cancelAlgorithm,r,o)}function SetUpReadableStreamBYOBRequest(e,t,r){e._associatedReadableByteStreamController=t;e._view=r}function byobRequestBrandCheckException(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function byteStreamControllerBrandCheckException(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function AcquireReadableStreamBYOBReader(e){return new ReadableStreamBYOBReader(e)}function ReadableStreamAddReadIntoRequest(e,t){e._reader._readIntoRequests.push(t)}function ReadableStreamFulfillReadIntoRequest(e,t,r){const n=e._reader;const o=n._readIntoRequests.shift();if(r){o._closeSteps(t)}else{o._chunkSteps(t)}}function ReadableStreamGetNumReadIntoRequests(e){return e._reader._readIntoRequests.length}function ReadableStreamHasBYOBReader(e){const t=e._reader;if(t===undefined){return false}if(!IsReadableStreamBYOBReader(t)){return false}return true}class ReadableStreamBYOBReader{constructor(e){assertRequiredArgument(e,1,"ReadableStreamBYOBReader");assertReadableStream(e,"First parameter");if(IsReadableStreamLocked(e)){throw new TypeError("This stream has already been locked for exclusive reading by another reader")}if(!IsReadableByteStreamController(e._readableStreamController)){throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte "+"source")}ReadableStreamReaderGenericInitialize(this,e);this._readIntoRequests=new SimpleQueue}get closed(){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("closed"))}return this._closedPromise}cancel(e=undefined){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("cancel"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("cancel"))}return ReadableStreamReaderGenericCancel(this,e)}read(e){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("read"))}if(!ArrayBuffer.isView(e)){return promiseRejectedWith(new TypeError("view must be an array buffer view"))}if(e.byteLength===0){return promiseRejectedWith(new TypeError("view must have non-zero byteLength"))}if(e.buffer.byteLength===0){return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`))}if(IsDetachedBuffer(e.buffer));if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("read from"))}let t;let r;const n=newPromise(((e,n)=>{t=e;r=n}));const o={_chunkSteps:e=>t({value:e,done:false}),_closeSteps:e=>t({value:e,done:true}),_errorSteps:e=>r(e)};ReadableStreamBYOBReaderRead(this,e,o);return n}releaseLock(){if(!IsReadableStreamBYOBReader(this)){throw byobReaderBrandCheckException("releaseLock")}if(this._ownerReadableStream===undefined){return}if(this._readIntoRequests.length>0){throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled")}ReadableStreamReaderGenericRelease(this)}}Object.defineProperties(ReadableStreamBYOBReader.prototype,{cancel:{enumerable:true},read:{enumerable:true},releaseLock:{enumerable:true},closed:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamBYOBReader.prototype,t.toStringTag,{value:"ReadableStreamBYOBReader",configurable:true})}function IsReadableStreamBYOBReader(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")){return false}return e instanceof ReadableStreamBYOBReader}function ReadableStreamBYOBReaderRead(e,t,r){const n=e._ownerReadableStream;n._disturbed=true;if(n._state==="errored"){r._errorSteps(n._storedError)}else{ReadableByteStreamControllerPullInto(n._readableStreamController,t,r)}}function byobReaderBrandCheckException(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function ExtractHighWaterMark(e,t){const{highWaterMark:r}=e;if(r===undefined){return t}if(y(r)||r<0){throw new RangeError("Invalid highWaterMark")}return r}function ExtractSizeAlgorithm(e){const{size:t}=e;if(!t){return()=>1}return t}function convertQueuingStrategy(e,t){assertDictionary(e,t);const r=e===null||e===void 0?void 0:e.highWaterMark;const n=e===null||e===void 0?void 0:e.size;return{highWaterMark:r===undefined?undefined:convertUnrestrictedDouble(r),size:n===undefined?undefined:convertQueuingStrategySize(n,`${t} has member 'size' that`)}}function convertQueuingStrategySize(e,t){assertFunction(e,t);return t=>convertUnrestrictedDouble(e(t))}function convertUnderlyingSink(e,t){assertDictionary(e,t);const r=e===null||e===void 0?void 0:e.abort;const n=e===null||e===void 0?void 0:e.close;const o=e===null||e===void 0?void 0:e.start;const a=e===null||e===void 0?void 0:e.type;const i=e===null||e===void 0?void 0:e.write;return{abort:r===undefined?undefined:convertUnderlyingSinkAbortCallback(r,e,`${t} has member 'abort' that`),close:n===undefined?undefined:convertUnderlyingSinkCloseCallback(n,e,`${t} has member 'close' that`),start:o===undefined?undefined:convertUnderlyingSinkStartCallback(o,e,`${t} has member 'start' that`),write:i===undefined?undefined:convertUnderlyingSinkWriteCallback(i,e,`${t} has member 'write' that`),type:a}}function convertUnderlyingSinkAbortCallback(e,t,r){assertFunction(e,r);return r=>promiseCall(e,t,[r])}function convertUnderlyingSinkCloseCallback(e,t,r){assertFunction(e,r);return()=>promiseCall(e,t,[])}function convertUnderlyingSinkStartCallback(e,t,r){assertFunction(e,r);return r=>reflectCall(e,t,[r])}function convertUnderlyingSinkWriteCallback(e,t,r){assertFunction(e,r);return(r,n)=>promiseCall(e,t,[r,n])}function assertWritableStream(e,t){if(!IsWritableStream(e)){throw new TypeError(`${t} is not a WritableStream.`)}}function isAbortSignal(e){if(typeof e!=="object"||e===null){return false}try{return typeof e.aborted==="boolean"}catch(e){return false}}const R=typeof AbortController==="function";function createAbortController(){if(R){return new AbortController}return undefined}class WritableStream{constructor(e={},t={}){if(e===undefined){e=null}else{assertObject(e,"First parameter")}const r=convertQueuingStrategy(t,"Second parameter");const n=convertUnderlyingSink(e,"First parameter");InitializeWritableStream(this);const o=n.type;if(o!==undefined){throw new RangeError("Invalid type is specified")}const a=ExtractSizeAlgorithm(r);const i=ExtractHighWaterMark(r,1);SetUpWritableStreamDefaultControllerFromUnderlyingSink(this,n,i,a)}get locked(){if(!IsWritableStream(this)){throw streamBrandCheckException$2("locked")}return IsWritableStreamLocked(this)}abort(e=undefined){if(!IsWritableStream(this)){return promiseRejectedWith(streamBrandCheckException$2("abort"))}if(IsWritableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"))}return WritableStreamAbort(this,e)}close(){if(!IsWritableStream(this)){return promiseRejectedWith(streamBrandCheckException$2("close"))}if(IsWritableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"))}if(WritableStreamCloseQueuedOrInFlight(this)){return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"))}return WritableStreamClose(this)}getWriter(){if(!IsWritableStream(this)){throw streamBrandCheckException$2("getWriter")}return AcquireWritableStreamDefaultWriter(this)}}Object.defineProperties(WritableStream.prototype,{abort:{enumerable:true},close:{enumerable:true},getWriter:{enumerable:true},locked:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(WritableStream.prototype,t.toStringTag,{value:"WritableStream",configurable:true})}function AcquireWritableStreamDefaultWriter(e){return new WritableStreamDefaultWriter(e)}function CreateWritableStream(e,t,r,n,o=1,a=(()=>1)){const i=Object.create(WritableStream.prototype);InitializeWritableStream(i);const l=Object.create(WritableStreamDefaultController.prototype);SetUpWritableStreamDefaultController(i,l,e,t,r,n,o,a);return i}function InitializeWritableStream(e){e._state="writable";e._storedError=undefined;e._writer=undefined;e._writableStreamController=undefined;e._writeRequests=new SimpleQueue;e._inFlightWriteRequest=undefined;e._closeRequest=undefined;e._inFlightCloseRequest=undefined;e._pendingAbortRequest=undefined;e._backpressure=false}function IsWritableStream(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")){return false}return e instanceof WritableStream}function IsWritableStreamLocked(e){if(e._writer===undefined){return false}return true}function WritableStreamAbort(e,t){var r;if(e._state==="closed"||e._state==="errored"){return promiseResolvedWith(undefined)}e._writableStreamController._abortReason=t;(r=e._writableStreamController._abortController)===null||r===void 0?void 0:r.abort();const n=e._state;if(n==="closed"||n==="errored"){return promiseResolvedWith(undefined)}if(e._pendingAbortRequest!==undefined){return e._pendingAbortRequest._promise}let o=false;if(n==="erroring"){o=true;t=undefined}const a=newPromise(((r,n)=>{e._pendingAbortRequest={_promise:undefined,_resolve:r,_reject:n,_reason:t,_wasAlreadyErroring:o}}));e._pendingAbortRequest._promise=a;if(!o){WritableStreamStartErroring(e,t)}return a}function WritableStreamClose(e){const t=e._state;if(t==="closed"||t==="errored"){return promiseRejectedWith(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`))}const r=newPromise(((t,r)=>{const n={_resolve:t,_reject:r};e._closeRequest=n}));const n=e._writer;if(n!==undefined&&e._backpressure&&t==="writable"){defaultWriterReadyPromiseResolve(n)}WritableStreamDefaultControllerClose(e._writableStreamController);return r}function WritableStreamAddWriteRequest(e){const t=newPromise(((t,r)=>{const n={_resolve:t,_reject:r};e._writeRequests.push(n)}));return t}function WritableStreamDealWithRejection(e,t){const r=e._state;if(r==="writable"){WritableStreamStartErroring(e,t);return}WritableStreamFinishErroring(e)}function WritableStreamStartErroring(e,t){const r=e._writableStreamController;e._state="erroring";e._storedError=t;const n=e._writer;if(n!==undefined){WritableStreamDefaultWriterEnsureReadyPromiseRejected(n,t)}if(!WritableStreamHasOperationMarkedInFlight(e)&&r._started){WritableStreamFinishErroring(e)}}function WritableStreamFinishErroring(e){e._state="errored";e._writableStreamController[c]();const t=e._storedError;e._writeRequests.forEach((e=>{e._reject(t)}));e._writeRequests=new SimpleQueue;if(e._pendingAbortRequest===undefined){WritableStreamRejectCloseAndClosedPromiseIfNeeded(e);return}const r=e._pendingAbortRequest;e._pendingAbortRequest=undefined;if(r._wasAlreadyErroring){r._reject(t);WritableStreamRejectCloseAndClosedPromiseIfNeeded(e);return}const n=e._writableStreamController[d](r._reason);uponPromise(n,(()=>{r._resolve();WritableStreamRejectCloseAndClosedPromiseIfNeeded(e)}),(t=>{r._reject(t);WritableStreamRejectCloseAndClosedPromiseIfNeeded(e)}))}function WritableStreamFinishInFlightWrite(e){e._inFlightWriteRequest._resolve(undefined);e._inFlightWriteRequest=undefined}function WritableStreamFinishInFlightWriteWithError(e,t){e._inFlightWriteRequest._reject(t);e._inFlightWriteRequest=undefined;WritableStreamDealWithRejection(e,t)}function WritableStreamFinishInFlightClose(e){e._inFlightCloseRequest._resolve(undefined);e._inFlightCloseRequest=undefined;const t=e._state;if(t==="erroring"){e._storedError=undefined;if(e._pendingAbortRequest!==undefined){e._pendingAbortRequest._resolve();e._pendingAbortRequest=undefined}}e._state="closed";const r=e._writer;if(r!==undefined){defaultWriterClosedPromiseResolve(r)}}function WritableStreamFinishInFlightCloseWithError(e,t){e._inFlightCloseRequest._reject(t);e._inFlightCloseRequest=undefined;if(e._pendingAbortRequest!==undefined){e._pendingAbortRequest._reject(t);e._pendingAbortRequest=undefined}WritableStreamDealWithRejection(e,t)}function WritableStreamCloseQueuedOrInFlight(e){if(e._closeRequest===undefined&&e._inFlightCloseRequest===undefined){return false}return true}function WritableStreamHasOperationMarkedInFlight(e){if(e._inFlightWriteRequest===undefined&&e._inFlightCloseRequest===undefined){return false}return true}function WritableStreamMarkCloseRequestInFlight(e){e._inFlightCloseRequest=e._closeRequest;e._closeRequest=undefined}function WritableStreamMarkFirstWriteRequestInFlight(e){e._inFlightWriteRequest=e._writeRequests.shift()}function WritableStreamRejectCloseAndClosedPromiseIfNeeded(e){if(e._closeRequest!==undefined){e._closeRequest._reject(e._storedError);e._closeRequest=undefined}const t=e._writer;if(t!==undefined){defaultWriterClosedPromiseReject(t,e._storedError)}}function WritableStreamUpdateBackpressure(e,t){const r=e._writer;if(r!==undefined&&t!==e._backpressure){if(t){defaultWriterReadyPromiseReset(r)}else{defaultWriterReadyPromiseResolve(r)}}e._backpressure=t}class WritableStreamDefaultWriter{constructor(e){assertRequiredArgument(e,1,"WritableStreamDefaultWriter");assertWritableStream(e,"First parameter");if(IsWritableStreamLocked(e)){throw new TypeError("This stream has already been locked for exclusive writing by another writer")}this._ownerWritableStream=e;e._writer=this;const t=e._state;if(t==="writable"){if(!WritableStreamCloseQueuedOrInFlight(e)&&e._backpressure){defaultWriterReadyPromiseInitialize(this)}else{defaultWriterReadyPromiseInitializeAsResolved(this)}defaultWriterClosedPromiseInitialize(this)}else if(t==="erroring"){defaultWriterReadyPromiseInitializeAsRejected(this,e._storedError);defaultWriterClosedPromiseInitialize(this)}else if(t==="closed"){defaultWriterReadyPromiseInitializeAsResolved(this);defaultWriterClosedPromiseInitializeAsResolved(this)}else{const t=e._storedError;defaultWriterReadyPromiseInitializeAsRejected(this,t);defaultWriterClosedPromiseInitializeAsRejected(this,t)}}get closed(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("closed"))}return this._closedPromise}get desiredSize(){if(!IsWritableStreamDefaultWriter(this)){throw defaultWriterBrandCheckException("desiredSize")}if(this._ownerWritableStream===undefined){throw defaultWriterLockException("desiredSize")}return WritableStreamDefaultWriterGetDesiredSize(this)}get ready(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("ready"))}return this._readyPromise}abort(e=undefined){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("abort"))}if(this._ownerWritableStream===undefined){return promiseRejectedWith(defaultWriterLockException("abort"))}return WritableStreamDefaultWriterAbort(this,e)}close(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("close"))}const e=this._ownerWritableStream;if(e===undefined){return promiseRejectedWith(defaultWriterLockException("close"))}if(WritableStreamCloseQueuedOrInFlight(e)){return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"))}return WritableStreamDefaultWriterClose(this)}releaseLock(){if(!IsWritableStreamDefaultWriter(this)){throw defaultWriterBrandCheckException("releaseLock")}const e=this._ownerWritableStream;if(e===undefined){return}WritableStreamDefaultWriterRelease(this)}write(e=undefined){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("write"))}if(this._ownerWritableStream===undefined){return promiseRejectedWith(defaultWriterLockException("write to"))}return WritableStreamDefaultWriterWrite(this,e)}}Object.defineProperties(WritableStreamDefaultWriter.prototype,{abort:{enumerable:true},close:{enumerable:true},releaseLock:{enumerable:true},write:{enumerable:true},closed:{enumerable:true},desiredSize:{enumerable:true},ready:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(WritableStreamDefaultWriter.prototype,t.toStringTag,{value:"WritableStreamDefaultWriter",configurable:true})}function IsWritableStreamDefaultWriter(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")){return false}return e instanceof WritableStreamDefaultWriter}function WritableStreamDefaultWriterAbort(e,t){const r=e._ownerWritableStream;return WritableStreamAbort(r,t)}function WritableStreamDefaultWriterClose(e){const t=e._ownerWritableStream;return WritableStreamClose(t)}function WritableStreamDefaultWriterCloseWithErrorPropagation(e){const t=e._ownerWritableStream;const r=t._state;if(WritableStreamCloseQueuedOrInFlight(t)||r==="closed"){return promiseResolvedWith(undefined)}if(r==="errored"){return promiseRejectedWith(t._storedError)}return WritableStreamDefaultWriterClose(e)}function WritableStreamDefaultWriterEnsureClosedPromiseRejected(e,t){if(e._closedPromiseState==="pending"){defaultWriterClosedPromiseReject(e,t)}else{defaultWriterClosedPromiseResetToRejected(e,t)}}function WritableStreamDefaultWriterEnsureReadyPromiseRejected(e,t){if(e._readyPromiseState==="pending"){defaultWriterReadyPromiseReject(e,t)}else{defaultWriterReadyPromiseResetToRejected(e,t)}}function WritableStreamDefaultWriterGetDesiredSize(e){const t=e._ownerWritableStream;const r=t._state;if(r==="errored"||r==="erroring"){return null}if(r==="closed"){return 0}return WritableStreamDefaultControllerGetDesiredSize(t._writableStreamController)}function WritableStreamDefaultWriterRelease(e){const t=e._ownerWritableStream;const r=new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);WritableStreamDefaultWriterEnsureReadyPromiseRejected(e,r);WritableStreamDefaultWriterEnsureClosedPromiseRejected(e,r);t._writer=undefined;e._ownerWritableStream=undefined}function WritableStreamDefaultWriterWrite(e,t){const r=e._ownerWritableStream;const n=r._writableStreamController;const o=WritableStreamDefaultControllerGetChunkSize(n,t);if(r!==e._ownerWritableStream){return promiseRejectedWith(defaultWriterLockException("write to"))}const a=r._state;if(a==="errored"){return promiseRejectedWith(r._storedError)}if(WritableStreamCloseQueuedOrInFlight(r)||a==="closed"){return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"))}if(a==="erroring"){return promiseRejectedWith(r._storedError)}const i=WritableStreamAddWriteRequest(r);WritableStreamDefaultControllerWrite(n,t,o);return i}const g={};class WritableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("abortReason")}return this._abortReason}get signal(){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("signal")}if(this._abortController===undefined){throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported")}return this._abortController.signal}error(e=undefined){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("error")}const t=this._controlledWritableStream._state;if(t!=="writable"){return}WritableStreamDefaultControllerError(this,e)}[d](e){const t=this._abortAlgorithm(e);WritableStreamDefaultControllerClearAlgorithms(this);return t}[c](){ResetQueue(this)}}Object.defineProperties(WritableStreamDefaultController.prototype,{error:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(WritableStreamDefaultController.prototype,t.toStringTag,{value:"WritableStreamDefaultController",configurable:true})}function IsWritableStreamDefaultController(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream")){return false}return e instanceof WritableStreamDefaultController}function SetUpWritableStreamDefaultController(e,t,r,n,o,a,i,l){t._controlledWritableStream=e;e._writableStreamController=t;t._queue=undefined;t._queueTotalSize=undefined;ResetQueue(t);t._abortReason=undefined;t._abortController=createAbortController();t._started=false;t._strategySizeAlgorithm=l;t._strategyHWM=i;t._writeAlgorithm=n;t._closeAlgorithm=o;t._abortAlgorithm=a;const s=WritableStreamDefaultControllerGetBackpressure(t);WritableStreamUpdateBackpressure(e,s);const u=r();const d=promiseResolvedWith(u);uponPromise(d,(()=>{t._started=true;WritableStreamDefaultControllerAdvanceQueueIfNeeded(t)}),(r=>{t._started=true;WritableStreamDealWithRejection(e,r)}))}function SetUpWritableStreamDefaultControllerFromUnderlyingSink(e,t,r,n){const o=Object.create(WritableStreamDefaultController.prototype);let startAlgorithm=()=>undefined;let writeAlgorithm=()=>promiseResolvedWith(undefined);let closeAlgorithm=()=>promiseResolvedWith(undefined);let abortAlgorithm=()=>promiseResolvedWith(undefined);if(t.start!==undefined){startAlgorithm=()=>t.start(o)}if(t.write!==undefined){writeAlgorithm=e=>t.write(e,o)}if(t.close!==undefined){closeAlgorithm=()=>t.close()}if(t.abort!==undefined){abortAlgorithm=e=>t.abort(e)}SetUpWritableStreamDefaultController(e,o,startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,r,n)}function WritableStreamDefaultControllerClearAlgorithms(e){e._writeAlgorithm=undefined;e._closeAlgorithm=undefined;e._abortAlgorithm=undefined;e._strategySizeAlgorithm=undefined}function WritableStreamDefaultControllerClose(e){EnqueueValueWithSize(e,g,0);WritableStreamDefaultControllerAdvanceQueueIfNeeded(e)}function WritableStreamDefaultControllerGetChunkSize(e,t){try{return e._strategySizeAlgorithm(t)}catch(t){WritableStreamDefaultControllerErrorIfNeeded(e,t);return 1}}function WritableStreamDefaultControllerGetDesiredSize(e){return e._strategyHWM-e._queueTotalSize}function WritableStreamDefaultControllerWrite(e,t,r){try{EnqueueValueWithSize(e,t,r)}catch(t){WritableStreamDefaultControllerErrorIfNeeded(e,t);return}const n=e._controlledWritableStream;if(!WritableStreamCloseQueuedOrInFlight(n)&&n._state==="writable"){const t=WritableStreamDefaultControllerGetBackpressure(e);WritableStreamUpdateBackpressure(n,t)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(e)}function WritableStreamDefaultControllerAdvanceQueueIfNeeded(e){const t=e._controlledWritableStream;if(!e._started){return}if(t._inFlightWriteRequest!==undefined){return}const r=t._state;if(r==="erroring"){WritableStreamFinishErroring(t);return}if(e._queue.length===0){return}const n=PeekQueueValue(e);if(n===g){WritableStreamDefaultControllerProcessClose(e)}else{WritableStreamDefaultControllerProcessWrite(e,n)}}function WritableStreamDefaultControllerErrorIfNeeded(e,t){if(e._controlledWritableStream._state==="writable"){WritableStreamDefaultControllerError(e,t)}}function WritableStreamDefaultControllerProcessClose(e){const t=e._controlledWritableStream;WritableStreamMarkCloseRequestInFlight(t);DequeueValue(e);const r=e._closeAlgorithm();WritableStreamDefaultControllerClearAlgorithms(e);uponPromise(r,(()=>{WritableStreamFinishInFlightClose(t)}),(e=>{WritableStreamFinishInFlightCloseWithError(t,e)}))}function WritableStreamDefaultControllerProcessWrite(e,t){const r=e._controlledWritableStream;WritableStreamMarkFirstWriteRequestInFlight(r);const n=e._writeAlgorithm(t);uponPromise(n,(()=>{WritableStreamFinishInFlightWrite(r);const t=r._state;DequeueValue(e);if(!WritableStreamCloseQueuedOrInFlight(r)&&t==="writable"){const t=WritableStreamDefaultControllerGetBackpressure(e);WritableStreamUpdateBackpressure(r,t)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(e)}),(t=>{if(r._state==="writable"){WritableStreamDefaultControllerClearAlgorithms(e)}WritableStreamFinishInFlightWriteWithError(r,t)}))}function WritableStreamDefaultControllerGetBackpressure(e){const t=WritableStreamDefaultControllerGetDesiredSize(e);return t<=0}function WritableStreamDefaultControllerError(e,t){const r=e._controlledWritableStream;WritableStreamDefaultControllerClearAlgorithms(e);WritableStreamStartErroring(r,t)}function streamBrandCheckException$2(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function defaultControllerBrandCheckException$2(e){return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`)}function defaultWriterBrandCheckException(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function defaultWriterLockException(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function defaultWriterClosedPromiseInitialize(e){e._closedPromise=newPromise(((t,r)=>{e._closedPromise_resolve=t;e._closedPromise_reject=r;e._closedPromiseState="pending"}))}function defaultWriterClosedPromiseInitializeAsRejected(e,t){defaultWriterClosedPromiseInitialize(e);defaultWriterClosedPromiseReject(e,t)}function defaultWriterClosedPromiseInitializeAsResolved(e){defaultWriterClosedPromiseInitialize(e);defaultWriterClosedPromiseResolve(e)}function defaultWriterClosedPromiseReject(e,t){if(e._closedPromise_reject===undefined){return}setPromiseIsHandledToTrue(e._closedPromise);e._closedPromise_reject(t);e._closedPromise_resolve=undefined;e._closedPromise_reject=undefined;e._closedPromiseState="rejected"}function defaultWriterClosedPromiseResetToRejected(e,t){defaultWriterClosedPromiseInitializeAsRejected(e,t)}function defaultWriterClosedPromiseResolve(e){if(e._closedPromise_resolve===undefined){return}e._closedPromise_resolve(undefined);e._closedPromise_resolve=undefined;e._closedPromise_reject=undefined;e._closedPromiseState="resolved"}function defaultWriterReadyPromiseInitialize(e){e._readyPromise=newPromise(((t,r)=>{e._readyPromise_resolve=t;e._readyPromise_reject=r}));e._readyPromiseState="pending"}function defaultWriterReadyPromiseInitializeAsRejected(e,t){defaultWriterReadyPromiseInitialize(e);defaultWriterReadyPromiseReject(e,t)}function defaultWriterReadyPromiseInitializeAsResolved(e){defaultWriterReadyPromiseInitialize(e);defaultWriterReadyPromiseResolve(e)}function defaultWriterReadyPromiseReject(e,t){if(e._readyPromise_reject===undefined){return}setPromiseIsHandledToTrue(e._readyPromise);e._readyPromise_reject(t);e._readyPromise_resolve=undefined;e._readyPromise_reject=undefined;e._readyPromiseState="rejected"}function defaultWriterReadyPromiseReset(e){defaultWriterReadyPromiseInitialize(e)}function defaultWriterReadyPromiseResetToRejected(e,t){defaultWriterReadyPromiseInitializeAsRejected(e,t)}function defaultWriterReadyPromiseResolve(e){if(e._readyPromise_resolve===undefined){return}e._readyPromise_resolve(undefined);e._readyPromise_resolve=undefined;e._readyPromise_reject=undefined;e._readyPromiseState="fulfilled"}const _=typeof DOMException!=="undefined"?DOMException:undefined;function isDOMExceptionConstructor(e){if(!(typeof e==="function"||typeof e==="object")){return false}try{new e;return true}catch(e){return false}}function createDOMExceptionPolyfill(){const e=function DOMException(e,t){this.message=e||"";this.name=t||"Error";if(Error.captureStackTrace){Error.captureStackTrace(this,this.constructor)}};e.prototype=Object.create(Error.prototype);Object.defineProperty(e.prototype,"constructor",{value:e,writable:true,configurable:true});return e}const C=isDOMExceptionConstructor(_)?_:createDOMExceptionPolyfill();function ReadableStreamPipeTo(e,t,r,n,o,a){const i=AcquireReadableStreamDefaultReader(e);const l=AcquireWritableStreamDefaultWriter(t);e._disturbed=true;let s=false;let u=promiseResolvedWith(undefined);return newPromise(((d,c)=>{let f;if(a!==undefined){f=()=>{const r=new C("Aborted","AbortError");const a=[];if(!n){a.push((()=>{if(t._state==="writable"){return WritableStreamAbort(t,r)}return promiseResolvedWith(undefined)}))}if(!o){a.push((()=>{if(e._state==="readable"){return ReadableStreamCancel(e,r)}return promiseResolvedWith(undefined)}))}shutdownWithAction((()=>Promise.all(a.map((e=>e())))),true,r)};if(a.aborted){f();return}a.addEventListener("abort",f)}function pipeLoop(){return newPromise(((e,t)=>{function next(r){if(r){e()}else{PerformPromiseThen(pipeStep(),next,t)}}next(false)}))}function pipeStep(){if(s){return promiseResolvedWith(true)}return PerformPromiseThen(l._readyPromise,(()=>newPromise(((e,t)=>{ReadableStreamDefaultReaderRead(i,{_chunkSteps:t=>{u=PerformPromiseThen(WritableStreamDefaultWriterWrite(l,t),undefined,noop);e(false)},_closeSteps:()=>e(true),_errorSteps:t})}))))}isOrBecomesErrored(e,i._closedPromise,(e=>{if(!n){shutdownWithAction((()=>WritableStreamAbort(t,e)),true,e)}else{shutdown(true,e)}}));isOrBecomesErrored(t,l._closedPromise,(t=>{if(!o){shutdownWithAction((()=>ReadableStreamCancel(e,t)),true,t)}else{shutdown(true,t)}}));isOrBecomesClosed(e,i._closedPromise,(()=>{if(!r){shutdownWithAction((()=>WritableStreamDefaultWriterCloseWithErrorPropagation(l)))}else{shutdown()}}));if(WritableStreamCloseQueuedOrInFlight(t)||t._state==="closed"){const t=new TypeError("the destination writable stream closed before all data could be piped to it");if(!o){shutdownWithAction((()=>ReadableStreamCancel(e,t)),true,t)}else{shutdown(true,t)}}setPromiseIsHandledToTrue(pipeLoop());function waitForWritesToFinish(){const e=u;return PerformPromiseThen(u,(()=>e!==u?waitForWritesToFinish():undefined))}function isOrBecomesErrored(e,t,r){if(e._state==="errored"){r(e._storedError)}else{uponRejection(t,r)}}function isOrBecomesClosed(e,t,r){if(e._state==="closed"){r()}else{uponFulfillment(t,r)}}function shutdownWithAction(e,r,n){if(s){return}s=true;if(t._state==="writable"&&!WritableStreamCloseQueuedOrInFlight(t)){uponFulfillment(waitForWritesToFinish(),doTheRest)}else{doTheRest()}function doTheRest(){uponPromise(e(),(()=>finalize(r,n)),(e=>finalize(true,e)))}}function shutdown(e,r){if(s){return}s=true;if(t._state==="writable"&&!WritableStreamCloseQueuedOrInFlight(t)){uponFulfillment(waitForWritesToFinish(),(()=>finalize(e,r)))}else{finalize(e,r)}}function finalize(e,t){WritableStreamDefaultWriterRelease(l);ReadableStreamReaderGenericRelease(i);if(a!==undefined){a.removeEventListener("abort",f)}if(e){c(t)}else{d(undefined)}}}))}class ReadableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("desiredSize")}return ReadableStreamDefaultControllerGetDesiredSize(this)}close(){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("close")}if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)){throw new TypeError("The stream is not in a state that permits close")}ReadableStreamDefaultControllerClose(this)}enqueue(e=undefined){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("enqueue")}if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)){throw new TypeError("The stream is not in a state that permits enqueue")}return ReadableStreamDefaultControllerEnqueue(this,e)}error(e=undefined){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("error")}ReadableStreamDefaultControllerError(this,e)}[f](e){ResetQueue(this);const t=this._cancelAlgorithm(e);ReadableStreamDefaultControllerClearAlgorithms(this);return t}[m](e){const t=this._controlledReadableStream;if(this._queue.length>0){const r=DequeueValue(this);if(this._closeRequested&&this._queue.length===0){ReadableStreamDefaultControllerClearAlgorithms(this);ReadableStreamClose(t)}else{ReadableStreamDefaultControllerCallPullIfNeeded(this)}e._chunkSteps(r)}else{ReadableStreamAddReadRequest(t,e);ReadableStreamDefaultControllerCallPullIfNeeded(this)}}}Object.defineProperties(ReadableStreamDefaultController.prototype,{close:{enumerable:true},enqueue:{enumerable:true},error:{enumerable:true},desiredSize:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamDefaultController.prototype,t.toStringTag,{value:"ReadableStreamDefaultController",configurable:true})}function IsReadableStreamDefaultController(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")){return false}return e instanceof ReadableStreamDefaultController}function ReadableStreamDefaultControllerCallPullIfNeeded(e){const t=ReadableStreamDefaultControllerShouldCallPull(e);if(!t){return}if(e._pulling){e._pullAgain=true;return}e._pulling=true;const r=e._pullAlgorithm();uponPromise(r,(()=>{e._pulling=false;if(e._pullAgain){e._pullAgain=false;ReadableStreamDefaultControllerCallPullIfNeeded(e)}}),(t=>{ReadableStreamDefaultControllerError(e,t)}))}function ReadableStreamDefaultControllerShouldCallPull(e){const t=e._controlledReadableStream;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(e)){return false}if(!e._started){return false}if(IsReadableStreamLocked(t)&&ReadableStreamGetNumReadRequests(t)>0){return true}const r=ReadableStreamDefaultControllerGetDesiredSize(e);if(r>0){return true}return false}function ReadableStreamDefaultControllerClearAlgorithms(e){e._pullAlgorithm=undefined;e._cancelAlgorithm=undefined;e._strategySizeAlgorithm=undefined}function ReadableStreamDefaultControllerClose(e){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(e)){return}const t=e._controlledReadableStream;e._closeRequested=true;if(e._queue.length===0){ReadableStreamDefaultControllerClearAlgorithms(e);ReadableStreamClose(t)}}function ReadableStreamDefaultControllerEnqueue(e,t){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(e)){return}const r=e._controlledReadableStream;if(IsReadableStreamLocked(r)&&ReadableStreamGetNumReadRequests(r)>0){ReadableStreamFulfillReadRequest(r,t,false)}else{let r;try{r=e._strategySizeAlgorithm(t)}catch(t){ReadableStreamDefaultControllerError(e,t);throw t}try{EnqueueValueWithSize(e,t,r)}catch(t){ReadableStreamDefaultControllerError(e,t);throw t}}ReadableStreamDefaultControllerCallPullIfNeeded(e)}function ReadableStreamDefaultControllerError(e,t){const r=e._controlledReadableStream;if(r._state!=="readable"){return}ResetQueue(e);ReadableStreamDefaultControllerClearAlgorithms(e);ReadableStreamError(r,t)}function ReadableStreamDefaultControllerGetDesiredSize(e){const t=e._controlledReadableStream._state;if(t==="errored"){return null}if(t==="closed"){return 0}return e._strategyHWM-e._queueTotalSize}function ReadableStreamDefaultControllerHasBackpressure(e){if(ReadableStreamDefaultControllerShouldCallPull(e)){return false}return true}function ReadableStreamDefaultControllerCanCloseOrEnqueue(e){const t=e._controlledReadableStream._state;if(!e._closeRequested&&t==="readable"){return true}return false}function SetUpReadableStreamDefaultController(e,t,r,n,o,a,i){t._controlledReadableStream=e;t._queue=undefined;t._queueTotalSize=undefined;ResetQueue(t);t._started=false;t._closeRequested=false;t._pullAgain=false;t._pulling=false;t._strategySizeAlgorithm=i;t._strategyHWM=a;t._pullAlgorithm=n;t._cancelAlgorithm=o;e._readableStreamController=t;const l=r();uponPromise(promiseResolvedWith(l),(()=>{t._started=true;ReadableStreamDefaultControllerCallPullIfNeeded(t)}),(e=>{ReadableStreamDefaultControllerError(t,e)}))}function SetUpReadableStreamDefaultControllerFromUnderlyingSource(e,t,r,n){const o=Object.create(ReadableStreamDefaultController.prototype);let startAlgorithm=()=>undefined;let pullAlgorithm=()=>promiseResolvedWith(undefined);let cancelAlgorithm=()=>promiseResolvedWith(undefined);if(t.start!==undefined){startAlgorithm=()=>t.start(o)}if(t.pull!==undefined){pullAlgorithm=()=>t.pull(o)}if(t.cancel!==undefined){cancelAlgorithm=e=>t.cancel(e)}SetUpReadableStreamDefaultController(e,o,startAlgorithm,pullAlgorithm,cancelAlgorithm,r,n)}function defaultControllerBrandCheckException$1(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function ReadableStreamTee(e,t){if(IsReadableByteStreamController(e._readableStreamController)){return ReadableByteStreamTee(e)}return ReadableStreamDefaultTee(e)}function ReadableStreamDefaultTee(e,t){const r=AcquireReadableStreamDefaultReader(e);let n=false;let o=false;let a=false;let i;let l;let u;let d;let c;const f=newPromise((e=>{c=e}));function pullAlgorithm(){if(n){return promiseResolvedWith(undefined)}n=true;const e={_chunkSteps:e=>{s((()=>{n=false;const t=e;const r=e;if(!o){ReadableStreamDefaultControllerEnqueue(u._readableStreamController,t)}if(!a){ReadableStreamDefaultControllerEnqueue(d._readableStreamController,r)}}))},_closeSteps:()=>{n=false;if(!o){ReadableStreamDefaultControllerClose(u._readableStreamController)}if(!a){ReadableStreamDefaultControllerClose(d._readableStreamController)}if(!o||!a){c(undefined)}},_errorSteps:()=>{n=false}};ReadableStreamDefaultReaderRead(r,e);return promiseResolvedWith(undefined)}function cancel1Algorithm(t){o=true;i=t;if(a){const t=CreateArrayFromList([i,l]);const r=ReadableStreamCancel(e,t);c(r)}return f}function cancel2Algorithm(t){a=true;l=t;if(o){const t=CreateArrayFromList([i,l]);const r=ReadableStreamCancel(e,t);c(r)}return f}function startAlgorithm(){}u=CreateReadableStream(startAlgorithm,pullAlgorithm,cancel1Algorithm);d=CreateReadableStream(startAlgorithm,pullAlgorithm,cancel2Algorithm);uponRejection(r._closedPromise,(e=>{ReadableStreamDefaultControllerError(u._readableStreamController,e);ReadableStreamDefaultControllerError(d._readableStreamController,e);if(!o||!a){c(undefined)}}));return[u,d]}function ReadableByteStreamTee(e){let t=AcquireReadableStreamDefaultReader(e);let r=false;let n=false;let o=false;let a;let i;let l;let u;let d;const c=newPromise((e=>{d=e}));function forwardReaderError(e){uponRejection(e._closedPromise,(r=>{if(e!==t){return}ReadableByteStreamControllerError(l._readableStreamController,r);ReadableByteStreamControllerError(u._readableStreamController,r);if(!n||!o){d(undefined)}}))}function pullWithDefaultReader(){if(IsReadableStreamBYOBReader(t)){ReadableStreamReaderGenericRelease(t);t=AcquireReadableStreamDefaultReader(e);forwardReaderError(t)}const a={_chunkSteps:t=>{s((()=>{r=false;const a=t;let i=t;if(!n&&!o){try{i=CloneAsUint8Array(t)}catch(t){ReadableByteStreamControllerError(l._readableStreamController,t);ReadableByteStreamControllerError(u._readableStreamController,t);d(ReadableStreamCancel(e,t));return}}if(!n){ReadableByteStreamControllerEnqueue(l._readableStreamController,a)}if(!o){ReadableByteStreamControllerEnqueue(u._readableStreamController,i)}}))},_closeSteps:()=>{r=false;if(!n){ReadableByteStreamControllerClose(l._readableStreamController)}if(!o){ReadableByteStreamControllerClose(u._readableStreamController)}if(l._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(l._readableStreamController,0)}if(u._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(u._readableStreamController,0)}if(!n||!o){d(undefined)}},_errorSteps:()=>{r=false}};ReadableStreamDefaultReaderRead(t,a)}function pullWithBYOBReader(a,i){if(IsReadableStreamDefaultReader(t)){ReadableStreamReaderGenericRelease(t);t=AcquireReadableStreamBYOBReader(e);forwardReaderError(t)}const c=i?u:l;const f=i?l:u;const m={_chunkSteps:t=>{s((()=>{r=false;const a=i?o:n;const l=i?n:o;if(!l){let r;try{r=CloneAsUint8Array(t)}catch(t){ReadableByteStreamControllerError(c._readableStreamController,t);ReadableByteStreamControllerError(f._readableStreamController,t);d(ReadableStreamCancel(e,t));return}if(!a){ReadableByteStreamControllerRespondWithNewView(c._readableStreamController,t)}ReadableByteStreamControllerEnqueue(f._readableStreamController,r)}else if(!a){ReadableByteStreamControllerRespondWithNewView(c._readableStreamController,t)}}))},_closeSteps:e=>{r=false;const t=i?o:n;const a=i?n:o;if(!t){ReadableByteStreamControllerClose(c._readableStreamController)}if(!a){ReadableByteStreamControllerClose(f._readableStreamController)}if(e!==undefined){if(!t){ReadableByteStreamControllerRespondWithNewView(c._readableStreamController,e)}if(!a&&f._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(f._readableStreamController,0)}}if(!t||!a){d(undefined)}},_errorSteps:()=>{r=false}};ReadableStreamBYOBReaderRead(t,a,m)}function pull1Algorithm(){if(r){return promiseResolvedWith(undefined)}r=true;const e=ReadableByteStreamControllerGetBYOBRequest(l._readableStreamController);if(e===null){pullWithDefaultReader()}else{pullWithBYOBReader(e._view,false)}return promiseResolvedWith(undefined)}function pull2Algorithm(){if(r){return promiseResolvedWith(undefined)}r=true;const e=ReadableByteStreamControllerGetBYOBRequest(u._readableStreamController);if(e===null){pullWithDefaultReader()}else{pullWithBYOBReader(e._view,true)}return promiseResolvedWith(undefined)}function cancel1Algorithm(t){n=true;a=t;if(o){const t=CreateArrayFromList([a,i]);const r=ReadableStreamCancel(e,t);d(r)}return c}function cancel2Algorithm(t){o=true;i=t;if(n){const t=CreateArrayFromList([a,i]);const r=ReadableStreamCancel(e,t);d(r)}return c}function startAlgorithm(){return}l=CreateReadableByteStream(startAlgorithm,pull1Algorithm,cancel1Algorithm);u=CreateReadableByteStream(startAlgorithm,pull2Algorithm,cancel2Algorithm);forwardReaderError(t);return[l,u]}function convertUnderlyingDefaultOrByteSource(e,t){assertDictionary(e,t);const r=e;const n=r===null||r===void 0?void 0:r.autoAllocateChunkSize;const o=r===null||r===void 0?void 0:r.cancel;const a=r===null||r===void 0?void 0:r.pull;const i=r===null||r===void 0?void 0:r.start;const l=r===null||r===void 0?void 0:r.type;return{autoAllocateChunkSize:n===undefined?undefined:convertUnsignedLongLongWithEnforceRange(n,`${t} has member 'autoAllocateChunkSize' that`),cancel:o===undefined?undefined:convertUnderlyingSourceCancelCallback(o,r,`${t} has member 'cancel' that`),pull:a===undefined?undefined:convertUnderlyingSourcePullCallback(a,r,`${t} has member 'pull' that`),start:i===undefined?undefined:convertUnderlyingSourceStartCallback(i,r,`${t} has member 'start' that`),type:l===undefined?undefined:convertReadableStreamType(l,`${t} has member 'type' that`)}}function convertUnderlyingSourceCancelCallback(e,t,r){assertFunction(e,r);return r=>promiseCall(e,t,[r])}function convertUnderlyingSourcePullCallback(e,t,r){assertFunction(e,r);return r=>promiseCall(e,t,[r])}function convertUnderlyingSourceStartCallback(e,t,r){assertFunction(e,r);return r=>reflectCall(e,t,[r])}function convertReadableStreamType(e,t){e=`${e}`;if(e!=="bytes"){throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`)}return e}function convertReaderOptions(e,t){assertDictionary(e,t);const r=e===null||e===void 0?void 0:e.mode;return{mode:r===undefined?undefined:convertReadableStreamReaderMode(r,`${t} has member 'mode' that`)}}function convertReadableStreamReaderMode(e,t){e=`${e}`;if(e!=="byob"){throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`)}return e}function convertIteratorOptions(e,t){assertDictionary(e,t);const r=e===null||e===void 0?void 0:e.preventCancel;return{preventCancel:Boolean(r)}}function convertPipeOptions(e,t){assertDictionary(e,t);const r=e===null||e===void 0?void 0:e.preventAbort;const n=e===null||e===void 0?void 0:e.preventCancel;const o=e===null||e===void 0?void 0:e.preventClose;const a=e===null||e===void 0?void 0:e.signal;if(a!==undefined){assertAbortSignal(a,`${t} has member 'signal' that`)}return{preventAbort:Boolean(r),preventCancel:Boolean(n),preventClose:Boolean(o),signal:a}}function assertAbortSignal(e,t){if(!isAbortSignal(e)){throw new TypeError(`${t} is not an AbortSignal.`)}}function convertReadableWritablePair(e,t){assertDictionary(e,t);const r=e===null||e===void 0?void 0:e.readable;assertRequiredField(r,"readable","ReadableWritablePair");assertReadableStream(r,`${t} has member 'readable' that`);const n=e===null||e===void 0?void 0:e.writable;assertRequiredField(n,"writable","ReadableWritablePair");assertWritableStream(n,`${t} has member 'writable' that`);return{readable:r,writable:n}}class ReadableStream{constructor(e={},t={}){if(e===undefined){e=null}else{assertObject(e,"First parameter")}const r=convertQueuingStrategy(t,"Second parameter");const n=convertUnderlyingDefaultOrByteSource(e,"First parameter");InitializeReadableStream(this);if(n.type==="bytes"){if(r.size!==undefined){throw new RangeError("The strategy for a byte stream cannot have a size function")}const e=ExtractHighWaterMark(r,0);SetUpReadableByteStreamControllerFromUnderlyingSource(this,n,e)}else{const e=ExtractSizeAlgorithm(r);const t=ExtractHighWaterMark(r,1);SetUpReadableStreamDefaultControllerFromUnderlyingSource(this,n,t,e)}}get locked(){if(!IsReadableStream(this)){throw streamBrandCheckException$1("locked")}return IsReadableStreamLocked(this)}cancel(e=undefined){if(!IsReadableStream(this)){return promiseRejectedWith(streamBrandCheckException$1("cancel"))}if(IsReadableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"))}return ReadableStreamCancel(this,e)}getReader(e=undefined){if(!IsReadableStream(this)){throw streamBrandCheckException$1("getReader")}const t=convertReaderOptions(e,"First parameter");if(t.mode===undefined){return AcquireReadableStreamDefaultReader(this)}return AcquireReadableStreamBYOBReader(this)}pipeThrough(e,t={}){if(!IsReadableStream(this)){throw streamBrandCheckException$1("pipeThrough")}assertRequiredArgument(e,1,"pipeThrough");const r=convertReadableWritablePair(e,"First parameter");const n=convertPipeOptions(t,"Second parameter");if(IsReadableStreamLocked(this)){throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream")}if(IsWritableStreamLocked(r.writable)){throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream")}const o=ReadableStreamPipeTo(this,r.writable,n.preventClose,n.preventAbort,n.preventCancel,n.signal);setPromiseIsHandledToTrue(o);return r.readable}pipeTo(e,t={}){if(!IsReadableStream(this)){return promiseRejectedWith(streamBrandCheckException$1("pipeTo"))}if(e===undefined){return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`)}if(!IsWritableStream(e)){return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`))}let r;try{r=convertPipeOptions(t,"Second parameter")}catch(e){return promiseRejectedWith(e)}if(IsReadableStreamLocked(this)){return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"))}if(IsWritableStreamLocked(e)){return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"))}return ReadableStreamPipeTo(this,e,r.preventClose,r.preventAbort,r.preventCancel,r.signal)}tee(){if(!IsReadableStream(this)){throw streamBrandCheckException$1("tee")}const e=ReadableStreamTee(this);return CreateArrayFromList(e)}values(e=undefined){if(!IsReadableStream(this)){throw streamBrandCheckException$1("values")}const t=convertIteratorOptions(e,"First parameter");return AcquireReadableStreamAsyncIterator(this,t.preventCancel)}}Object.defineProperties(ReadableStream.prototype,{cancel:{enumerable:true},getReader:{enumerable:true},pipeThrough:{enumerable:true},pipeTo:{enumerable:true},tee:{enumerable:true},values:{enumerable:true},locked:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStream.prototype,t.toStringTag,{value:"ReadableStream",configurable:true})}if(typeof t.asyncIterator==="symbol"){Object.defineProperty(ReadableStream.prototype,t.asyncIterator,{value:ReadableStream.prototype.values,writable:true,configurable:true})}function CreateReadableStream(e,t,r,n=1,o=(()=>1)){const a=Object.create(ReadableStream.prototype);InitializeReadableStream(a);const i=Object.create(ReadableStreamDefaultController.prototype);SetUpReadableStreamDefaultController(a,i,e,t,r,n,o);return a}function CreateReadableByteStream(e,t,r){const n=Object.create(ReadableStream.prototype);InitializeReadableStream(n);const o=Object.create(ReadableByteStreamController.prototype);SetUpReadableByteStreamController(n,o,e,t,r,0,undefined);return n}function InitializeReadableStream(e){e._state="readable";e._reader=undefined;e._storedError=undefined;e._disturbed=false}function IsReadableStream(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")){return false}return e instanceof ReadableStream}function IsReadableStreamLocked(e){if(e._reader===undefined){return false}return true}function ReadableStreamCancel(e,t){e._disturbed=true;if(e._state==="closed"){return promiseResolvedWith(undefined)}if(e._state==="errored"){return promiseRejectedWith(e._storedError)}ReadableStreamClose(e);const r=e._reader;if(r!==undefined&&IsReadableStreamBYOBReader(r)){r._readIntoRequests.forEach((e=>{e._closeSteps(undefined)}));r._readIntoRequests=new SimpleQueue}const n=e._readableStreamController[f](t);return transformPromiseWith(n,noop)}function ReadableStreamClose(e){e._state="closed";const t=e._reader;if(t===undefined){return}defaultReaderClosedPromiseResolve(t);if(IsReadableStreamDefaultReader(t)){t._readRequests.forEach((e=>{e._closeSteps()}));t._readRequests=new SimpleQueue}}function ReadableStreamError(e,t){e._state="errored";e._storedError=t;const r=e._reader;if(r===undefined){return}defaultReaderClosedPromiseReject(r,t);if(IsReadableStreamDefaultReader(r)){r._readRequests.forEach((e=>{e._errorSteps(t)}));r._readRequests=new SimpleQueue}else{r._readIntoRequests.forEach((e=>{e._errorSteps(t)}));r._readIntoRequests=new SimpleQueue}}function streamBrandCheckException$1(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function convertQueuingStrategyInit(e,t){assertDictionary(e,t);const r=e===null||e===void 0?void 0:e.highWaterMark;assertRequiredField(r,"highWaterMark","QueuingStrategyInit");return{highWaterMark:convertUnrestrictedDouble(r)}}const byteLengthSizeFunction=e=>e.byteLength;Object.defineProperty(byteLengthSizeFunction,"name",{value:"size",configurable:true});class ByteLengthQueuingStrategy{constructor(e){assertRequiredArgument(e,1,"ByteLengthQueuingStrategy");e=convertQueuingStrategyInit(e,"First parameter");this._byteLengthQueuingStrategyHighWaterMark=e.highWaterMark}get highWaterMark(){if(!IsByteLengthQueuingStrategy(this)){throw byteLengthBrandCheckException("highWaterMark")}return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!IsByteLengthQueuingStrategy(this)){throw byteLengthBrandCheckException("size")}return byteLengthSizeFunction}}Object.defineProperties(ByteLengthQueuingStrategy.prototype,{highWaterMark:{enumerable:true},size:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ByteLengthQueuingStrategy.prototype,t.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:true})}function byteLengthBrandCheckException(e){return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`)}function IsByteLengthQueuingStrategy(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_byteLengthQueuingStrategyHighWaterMark")){return false}return e instanceof ByteLengthQueuingStrategy}const countSizeFunction=()=>1;Object.defineProperty(countSizeFunction,"name",{value:"size",configurable:true});class CountQueuingStrategy{constructor(e){assertRequiredArgument(e,1,"CountQueuingStrategy");e=convertQueuingStrategyInit(e,"First parameter");this._countQueuingStrategyHighWaterMark=e.highWaterMark}get highWaterMark(){if(!IsCountQueuingStrategy(this)){throw countBrandCheckException("highWaterMark")}return this._countQueuingStrategyHighWaterMark}get size(){if(!IsCountQueuingStrategy(this)){throw countBrandCheckException("size")}return countSizeFunction}}Object.defineProperties(CountQueuingStrategy.prototype,{highWaterMark:{enumerable:true},size:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(CountQueuingStrategy.prototype,t.toStringTag,{value:"CountQueuingStrategy",configurable:true})}function countBrandCheckException(e){return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`)}function IsCountQueuingStrategy(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_countQueuingStrategyHighWaterMark")){return false}return e instanceof CountQueuingStrategy}function convertTransformer(e,t){assertDictionary(e,t);const r=e===null||e===void 0?void 0:e.flush;const n=e===null||e===void 0?void 0:e.readableType;const o=e===null||e===void 0?void 0:e.start;const a=e===null||e===void 0?void 0:e.transform;const i=e===null||e===void 0?void 0:e.writableType;return{flush:r===undefined?undefined:convertTransformerFlushCallback(r,e,`${t} has member 'flush' that`),readableType:n,start:o===undefined?undefined:convertTransformerStartCallback(o,e,`${t} has member 'start' that`),transform:a===undefined?undefined:convertTransformerTransformCallback(a,e,`${t} has member 'transform' that`),writableType:i}}function convertTransformerFlushCallback(e,t,r){assertFunction(e,r);return r=>promiseCall(e,t,[r])}function convertTransformerStartCallback(e,t,r){assertFunction(e,r);return r=>reflectCall(e,t,[r])}function convertTransformerTransformCallback(e,t,r){assertFunction(e,r);return(r,n)=>promiseCall(e,t,[r,n])}class TransformStream{constructor(e={},t={},r={}){if(e===undefined){e=null}const n=convertQueuingStrategy(t,"Second parameter");const o=convertQueuingStrategy(r,"Third parameter");const a=convertTransformer(e,"First parameter");if(a.readableType!==undefined){throw new RangeError("Invalid readableType specified")}if(a.writableType!==undefined){throw new RangeError("Invalid writableType specified")}const i=ExtractHighWaterMark(o,0);const l=ExtractSizeAlgorithm(o);const s=ExtractHighWaterMark(n,1);const u=ExtractSizeAlgorithm(n);let d;const c=newPromise((e=>{d=e}));InitializeTransformStream(this,c,s,u,i,l);SetUpTransformStreamDefaultControllerFromTransformer(this,a);if(a.start!==undefined){d(a.start(this._transformStreamController))}else{d(undefined)}}get readable(){if(!IsTransformStream(this)){throw streamBrandCheckException("readable")}return this._readable}get writable(){if(!IsTransformStream(this)){throw streamBrandCheckException("writable")}return this._writable}}Object.defineProperties(TransformStream.prototype,{readable:{enumerable:true},writable:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(TransformStream.prototype,t.toStringTag,{value:"TransformStream",configurable:true})}function InitializeTransformStream(e,t,r,n,o,a){function startAlgorithm(){return t}function writeAlgorithm(t){return TransformStreamDefaultSinkWriteAlgorithm(e,t)}function abortAlgorithm(t){return TransformStreamDefaultSinkAbortAlgorithm(e,t)}function closeAlgorithm(){return TransformStreamDefaultSinkCloseAlgorithm(e)}e._writable=CreateWritableStream(startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,r,n);function pullAlgorithm(){return TransformStreamDefaultSourcePullAlgorithm(e)}function cancelAlgorithm(t){TransformStreamErrorWritableAndUnblockWrite(e,t);return promiseResolvedWith(undefined)}e._readable=CreateReadableStream(startAlgorithm,pullAlgorithm,cancelAlgorithm,o,a);e._backpressure=undefined;e._backpressureChangePromise=undefined;e._backpressureChangePromise_resolve=undefined;TransformStreamSetBackpressure(e,true);e._transformStreamController=undefined}function IsTransformStream(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")){return false}return e instanceof TransformStream}function TransformStreamError(e,t){ReadableStreamDefaultControllerError(e._readable._readableStreamController,t);TransformStreamErrorWritableAndUnblockWrite(e,t)}function TransformStreamErrorWritableAndUnblockWrite(e,t){TransformStreamDefaultControllerClearAlgorithms(e._transformStreamController);WritableStreamDefaultControllerErrorIfNeeded(e._writable._writableStreamController,t);if(e._backpressure){TransformStreamSetBackpressure(e,false)}}function TransformStreamSetBackpressure(e,t){if(e._backpressureChangePromise!==undefined){e._backpressureChangePromise_resolve()}e._backpressureChangePromise=newPromise((t=>{e._backpressureChangePromise_resolve=t}));e._backpressure=t}class TransformStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("desiredSize")}const e=this._controlledTransformStream._readable._readableStreamController;return ReadableStreamDefaultControllerGetDesiredSize(e)}enqueue(e=undefined){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("enqueue")}TransformStreamDefaultControllerEnqueue(this,e)}error(e=undefined){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("error")}TransformStreamDefaultControllerError(this,e)}terminate(){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("terminate")}TransformStreamDefaultControllerTerminate(this)}}Object.defineProperties(TransformStreamDefaultController.prototype,{enqueue:{enumerable:true},error:{enumerable:true},terminate:{enumerable:true},desiredSize:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(TransformStreamDefaultController.prototype,t.toStringTag,{value:"TransformStreamDefaultController",configurable:true})}function IsTransformStreamDefaultController(e){if(!typeIsObject(e)){return false}if(!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")){return false}return e instanceof TransformStreamDefaultController}function SetUpTransformStreamDefaultController(e,t,r,n){t._controlledTransformStream=e;e._transformStreamController=t;t._transformAlgorithm=r;t._flushAlgorithm=n}function SetUpTransformStreamDefaultControllerFromTransformer(e,t){const r=Object.create(TransformStreamDefaultController.prototype);let transformAlgorithm=e=>{try{TransformStreamDefaultControllerEnqueue(r,e);return promiseResolvedWith(undefined)}catch(e){return promiseRejectedWith(e)}};let flushAlgorithm=()=>promiseResolvedWith(undefined);if(t.transform!==undefined){transformAlgorithm=e=>t.transform(e,r)}if(t.flush!==undefined){flushAlgorithm=()=>t.flush(r)}SetUpTransformStreamDefaultController(e,r,transformAlgorithm,flushAlgorithm)}function TransformStreamDefaultControllerClearAlgorithms(e){e._transformAlgorithm=undefined;e._flushAlgorithm=undefined}function TransformStreamDefaultControllerEnqueue(e,t){const r=e._controlledTransformStream;const n=r._readable._readableStreamController;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(n)){throw new TypeError("Readable side is not in a state that permits enqueue")}try{ReadableStreamDefaultControllerEnqueue(n,t)}catch(e){TransformStreamErrorWritableAndUnblockWrite(r,e);throw r._readable._storedError}const o=ReadableStreamDefaultControllerHasBackpressure(n);if(o!==r._backpressure){TransformStreamSetBackpressure(r,true)}}function TransformStreamDefaultControllerError(e,t){TransformStreamError(e._controlledTransformStream,t)}function TransformStreamDefaultControllerPerformTransform(e,t){const r=e._transformAlgorithm(t);return transformPromiseWith(r,undefined,(t=>{TransformStreamError(e._controlledTransformStream,t);throw t}))}function TransformStreamDefaultControllerTerminate(e){const t=e._controlledTransformStream;const r=t._readable._readableStreamController;ReadableStreamDefaultControllerClose(r);const n=new TypeError("TransformStream terminated");TransformStreamErrorWritableAndUnblockWrite(t,n)}function TransformStreamDefaultSinkWriteAlgorithm(e,t){const r=e._transformStreamController;if(e._backpressure){const n=e._backpressureChangePromise;return transformPromiseWith(n,(()=>{const n=e._writable;const o=n._state;if(o==="erroring"){throw n._storedError}return TransformStreamDefaultControllerPerformTransform(r,t)}))}return TransformStreamDefaultControllerPerformTransform(r,t)}function TransformStreamDefaultSinkAbortAlgorithm(e,t){TransformStreamError(e,t);return promiseResolvedWith(undefined)}function TransformStreamDefaultSinkCloseAlgorithm(e){const t=e._readable;const r=e._transformStreamController;const n=r._flushAlgorithm();TransformStreamDefaultControllerClearAlgorithms(r);return transformPromiseWith(n,(()=>{if(t._state==="errored"){throw t._storedError}ReadableStreamDefaultControllerClose(t._readableStreamController)}),(r=>{TransformStreamError(e,r);throw t._storedError}))}function TransformStreamDefaultSourcePullAlgorithm(e){TransformStreamSetBackpressure(e,false);return e._backpressureChangePromise}function defaultControllerBrandCheckException(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function streamBrandCheckException(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}e.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy;e.CountQueuingStrategy=CountQueuingStrategy;e.ReadableByteStreamController=ReadableByteStreamController;e.ReadableStream=ReadableStream;e.ReadableStreamBYOBReader=ReadableStreamBYOBReader;e.ReadableStreamBYOBRequest=ReadableStreamBYOBRequest;e.ReadableStreamDefaultController=ReadableStreamDefaultController;e.ReadableStreamDefaultReader=ReadableStreamDefaultReader;e.TransformStream=TransformStream;e.TransformStreamDefaultController=TransformStreamDefaultController;e.WritableStream=WritableStream;e.WritableStreamDefaultController=WritableStreamDefaultController;e.WritableStreamDefaultWriter=WritableStreamDefaultWriter;Object.defineProperty(e,"__esModule",{value:true})}))},81:module=>{module.exports=eval("require")("stream/web")},10:(e,t,r)=>{const n=65536;if(!globalThis.ReadableStream){try{Object.assign(globalThis,r(81))}catch(e){Object.assign(globalThis,r(452))}}try{const{Blob:e}=r(293);if(e&&!e.prototype.stream){e.prototype.stream=function name(e){let t=0;const r=this;return new ReadableStream({type:"bytes",async pull(e){const o=r.slice(t,Math.min(r.size,t+n));const a=await o.arrayBuffer();t+=a.byteLength;e.enqueue(new Uint8Array(a));if(t===r.size){e.close()}}})}}}catch(e){}},357:e=>{"use strict";e.exports=require("assert")},293:e=>{"use strict";e.exports=require("buffer")},129:e=>{"use strict";e.exports=require("child_process")},614:e=>{"use strict";e.exports=require("events")},747:e=>{"use strict";e.exports=require("fs")},87:e=>{"use strict";e.exports=require("os")},622:e=>{"use strict";e.exports=require("path")},413:e=>{"use strict";e.exports=require("stream")},304:e=>{"use strict";e.exports=require("string_decoder")},213:e=>{"use strict";e.exports=require("timers")},669:e=>{"use strict";e.exports=require("util")}};var __webpack_module_cache__={};function __nccwpck_require__(e){var t=__webpack_module_cache__[e];if(t!==undefined){return t.exports}var r=__webpack_module_cache__[e]={exports:{}};var n=true;try{__webpack_modules__[e].call(r.exports,r,r.exports,__nccwpck_require__);n=false}finally{if(n)delete __webpack_module_cache__[e]}return r.exports}(()=>{__nccwpck_require__.n=e=>{var t=e&&e.__esModule?()=>e["default"]:()=>e;__nccwpck_require__.d(t,{a:t});return t}})();(()=>{__nccwpck_require__.d=(e,t)=>{for(var r in t){if(__nccwpck_require__.o(t,r)&&!__nccwpck_require__.o(e,r)){Object.defineProperty(e,r,{enumerable:true,get:t[r]})}}}})();(()=>{__nccwpck_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)})();(()=>{__nccwpck_require__.r=e=>{if(typeof Symbol!=="undefined"&&Symbol.toStringTag){Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}Object.defineProperty(e,"__esModule",{value:true})}})();if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var __webpack_exports__={};(()=>{"use strict";__nccwpck_require__.r(__webpack_exports__);var e=__nccwpck_require__(514);var t=__nccwpck_require__(186);var r=__nccwpck_require__(622);var n=__nccwpck_require__(400);var o=__nccwpck_require__(747);var a=__nccwpck_require__.n(o);const i=require("http");const l=require("https");const s=require("zlib");var u=__nccwpck_require__(413);var d=__nccwpck_require__(371);var c=__nccwpck_require__(669);var f=__nccwpck_require__.n(c);var m=__nccwpck_require__(10);const h=65536;async function*toIterator(e,t=true){for(let r of e){if("stream"in r){yield*r.stream()}else if(ArrayBuffer.isView(r)){if(t){let e=r.byteOffset;let t=r.byteOffset+r.byteLength;while(e!==t){const n=Math.min(t-e,h);const o=r.buffer.slice(e,e+n);e+=o.byteLength;yield new Uint8Array(o)}}else{yield r}}else{let e=0;while(e!==r.size){const t=r.slice(e,Math.min(r.size,e+h));const n=await t.arrayBuffer();e+=n.byteLength;yield new Uint8Array(n)}}}}const b=class Blob{#parts=[];#type="";#size=0;constructor(e=[],t={}){let r=0;const n=e.map((e=>{let t;if(ArrayBuffer.isView(e)){t=new Uint8Array(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength))}else if(e instanceof ArrayBuffer){t=new Uint8Array(e.slice(0))}else if(e instanceof Blob){t=e}else{t=(new TextEncoder).encode(e)}r+=ArrayBuffer.isView(t)?t.byteLength:t.size;return t}));const o=t.type===undefined?"":String(t.type);this.#type=/[^\u0020-\u007E]/.test(o)?"":o;this.#size=r;this.#parts=n}get size(){return this.#size}get type(){return this.#type}async text(){const e=new TextDecoder;let t="";for await(let r of toIterator(this.#parts,false)){t+=e.decode(r,{stream:true})}t+=e.decode();return t}async arrayBuffer(){const e=new Uint8Array(this.size);let t=0;for await(const r of toIterator(this.#parts,false)){e.set(r,t);t+=r.length}return e.buffer}stream(){const e=toIterator(this.#parts,true);return new ReadableStream({type:"bytes",async pull(t){const r=await e.next();r.done?t.close():t.enqueue(r.value)}})}slice(e=0,t=this.size,r=""){const{size:n}=this;let o=e<0?Math.max(n+e,0):Math.min(e,n);let a=t<0?Math.max(n+t,0):Math.min(t,n);const i=Math.max(a-o,0);const l=this.#parts;const s=[];let u=0;for(const e of l){if(u>=i){break}const t=ArrayBuffer.isView(e)?e.byteLength:e.size;if(o&&t<=o){o-=t;a-=t}else{let r;if(ArrayBuffer.isView(e)){r=e.subarray(o,Math.min(t,a));u+=r.byteLength}else{r=e.slice(o,Math.min(t,a));u+=r.size}s.push(r);o=0}}const d=new Blob([],{type:String(r).toLowerCase()});d.#size=i;d.#parts=s;return d}get[Symbol.toStringTag](){return"Blob"}static[Symbol.hasInstance](e){return e&&typeof e==="object"&&typeof e.constructor==="function"&&(typeof e.stream==="function"||typeof e.arrayBuffer==="function")&&/^(Blob|File)$/.test(e[Symbol.toStringTag])}};Object.defineProperties(b.prototype,{size:{enumerable:true},type:{enumerable:true},slice:{enumerable:true}});const p=b;const S=p;class FetchBaseError extends Error{constructor(e,t){super(e);Error.captureStackTrace(this,this.constructor);this.type=t}get name(){return this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}}class FetchError extends FetchBaseError{constructor(e,t,r){super(e,t);if(r){this.code=this.errno=r.code;this.erroredSysCall=r.syscall}}}const y=require("crypto");const R=Symbol.toStringTag;const isURLSearchParameters=e=>typeof e==="object"&&typeof e.append==="function"&&typeof e.delete==="function"&&typeof e.get==="function"&&typeof e.getAll==="function"&&typeof e.has==="function"&&typeof e.set==="function"&&typeof e.sort==="function"&&e[R]==="URLSearchParams";const isBlob=e=>typeof e==="object"&&typeof e.arrayBuffer==="function"&&typeof e.type==="string"&&typeof e.stream==="function"&&typeof e.constructor==="function"&&/^(Blob|File)$/.test(e[R]);function isFormData(e){return typeof e==="object"&&typeof e.append==="function"&&typeof e.set==="function"&&typeof e.get==="function"&&typeof e.getAll==="function"&&typeof e.delete==="function"&&typeof e.keys==="function"&&typeof e.values==="function"&&typeof e.entries==="function"&&typeof e.constructor==="function"&&e[R]==="FormData"}const isAbortSignal=e=>typeof e==="object"&&(e[R]==="AbortSignal"||e[R]==="EventTarget");const g="\r\n";const _="-".repeat(2);const C=Buffer.byteLength(g);const getFooter=e=>`${_}${e}${_}${g.repeat(2)}`;function getHeader(e,t,r){let n="";n+=`${_}${e}${g}`;n+=`Content-Disposition: form-data; name="${t}"`;if(isBlob(r)){n+=`; filename="${r.name}"${g}`;n+=`Content-Type: ${r.type||"application/octet-stream"}`}return`${n}${g.repeat(2)}`}const getBoundary=()=>(0,y.randomBytes)(8).toString("hex");async function*formDataIterator(e,t){for(const[r,n]of e){yield getHeader(t,r,n);if(isBlob(n)){yield*n.stream()}else{yield n}yield g}yield getFooter(t)}function getFormDataLength(e,t){let r=0;for(const[n,o]of e){r+=Buffer.byteLength(getHeader(t,n,o));r+=isBlob(o)?o.size:Buffer.byteLength(String(o));r+=C}r+=Buffer.byteLength(getFooter(t));return r}const w=Symbol("Body internals");class Body{constructor(e,{size:t=0}={}){let r=null;if(e===null){e=null}else if(isURLSearchParameters(e)){e=Buffer.from(e.toString())}else if(isBlob(e)){}else if(Buffer.isBuffer(e)){}else if(c.types.isAnyArrayBuffer(e)){e=Buffer.from(e)}else if(ArrayBuffer.isView(e)){e=Buffer.from(e.buffer,e.byteOffset,e.byteLength)}else if(e instanceof u){}else if(isFormData(e)){r=`NodeFetchFormDataBoundary${getBoundary()}`;e=u.Readable.from(formDataIterator(e,r))}else{e=Buffer.from(String(e))}this[w]={body:e,boundary:r,disturbed:false,error:null};this.size=t;if(e instanceof u){e.on("error",(e=>{const t=e instanceof FetchBaseError?e:new FetchError(`Invalid response body while trying to fetch ${this.url}: ${e.message}`,"system",e);this[w].error=t}))}}get body(){return this[w].body}get bodyUsed(){return this[w].disturbed}async arrayBuffer(){const{buffer:e,byteOffset:t,byteLength:r}=await consumeBody(this);return e.slice(t,t+r)}async blob(){const e=this.headers&&this.headers.get("content-type")||this[w].body&&this[w].body.type||"";const t=await this.buffer();return new S([t],{type:e})}async json(){const e=await consumeBody(this);return JSON.parse(e.toString())}async text(){const e=await consumeBody(this);return e.toString()}buffer(){return consumeBody(this)}}Object.defineProperties(Body.prototype,{body:{enumerable:true},bodyUsed:{enumerable:true},arrayBuffer:{enumerable:true},blob:{enumerable:true},json:{enumerable:true},text:{enumerable:true}});async function consumeBody(e){if(e[w].disturbed){throw new TypeError(`body used already for: ${e.url}`)}e[w].disturbed=true;if(e[w].error){throw e[w].error}let{body:t}=e;if(t===null){return Buffer.alloc(0)}if(isBlob(t)){t=u.Readable.from(t.stream())}if(Buffer.isBuffer(t)){return t}if(!(t instanceof u)){return Buffer.alloc(0)}const r=[];let n=0;try{for await(const o of t){if(e.size>0&&n+o.length>e.size){const r=new FetchError(`content size at ${e.url} over limit: ${e.size}`,"max-size");t.destroy(r);throw r}n+=o.length;r.push(o)}}catch(t){const r=t instanceof FetchBaseError?t:new FetchError(`Invalid response body while trying to fetch ${e.url}: ${t.message}`,"system",t);throw r}if(t.readableEnded===true||t._readableState.ended===true){try{if(r.every((e=>typeof e==="string"))){return Buffer.from(r.join(""))}return Buffer.concat(r,n)}catch(t){throw new FetchError(`Could not create Buffer from response body for ${e.url}: ${t.message}`,"system",t)}}else{throw new FetchError(`Premature close of server response while trying to fetch ${e.url}`)}}const clone=(e,t)=>{let r;let n;let{body:o}=e;if(e.bodyUsed){throw new Error("cannot clone body after it is used")}if(o instanceof u&&typeof o.getBoundary!=="function"){r=new u.PassThrough({highWaterMark:t});n=new u.PassThrough({highWaterMark:t});o.pipe(r);o.pipe(n);e[w].body=r;o=n}return o};const extractContentType=(e,t)=>{if(e===null){return null}if(typeof e==="string"){return"text/plain;charset=UTF-8"}if(isURLSearchParameters(e)){return"application/x-www-form-urlencoded;charset=UTF-8"}if(isBlob(e)){return e.type||null}if(Buffer.isBuffer(e)||c.types.isAnyArrayBuffer(e)||ArrayBuffer.isView(e)){return null}if(e&&typeof e.getBoundary==="function"){return`multipart/form-data;boundary=${e.getBoundary()}`}if(isFormData(e)){return`multipart/form-data; boundary=${t[w].boundary}`}if(e instanceof u){return null}return"text/plain;charset=UTF-8"};const getTotalBytes=e=>{const{body:t}=e;if(t===null){return 0}if(isBlob(t)){return t.size}if(Buffer.isBuffer(t)){return t.length}if(t&&typeof t.getLengthSync==="function"){return t.hasKnownLength&&t.hasKnownLength()?t.getLengthSync():null}if(isFormData(t)){return getFormDataLength(e[w].boundary)}return null};const writeToStream=(e,{body:t})=>{if(t===null){e.end()}else if(isBlob(t)){u.Readable.from(t.stream()).pipe(e)}else if(Buffer.isBuffer(t)){e.write(t);e.end()}else{t.pipe(e)}};const v=typeof i.validateHeaderName==="function"?i.validateHeaderName:e=>{if(!/^[\^`\-\w!#$%&'*+.|~]+$/.test(e)){const t=new TypeError(`Header name must be a valid HTTP token [${e}]`);Object.defineProperty(t,"code",{value:"ERR_INVALID_HTTP_TOKEN"});throw t}};const W=typeof i.validateHeaderValue==="function"?i.validateHeaderValue:(e,t)=>{if(/[^\t\u0020-\u007E\u0080-\u00FF]/.test(t)){const t=new TypeError(`Invalid character in header content ["${e}"]`);Object.defineProperty(t,"code",{value:"ERR_INVALID_CHAR"});throw t}};class Headers extends URLSearchParams{constructor(e){let t=[];if(e instanceof Headers){const r=e.raw();for(const[e,n]of Object.entries(r)){t.push(...n.map((t=>[e,t])))}}else if(e==null){}else if(typeof e==="object"&&!c.types.isBoxedPrimitive(e)){const r=e[Symbol.iterator];if(r==null){t.push(...Object.entries(e))}else{if(typeof r!=="function"){throw new TypeError("Header pairs must be iterable")}t=[...e].map((e=>{if(typeof e!=="object"||c.types.isBoxedPrimitive(e)){throw new TypeError("Each header pair must be an iterable object")}return[...e]})).map((e=>{if(e.length!==2){throw new TypeError("Each header pair must be a name/value tuple")}return[...e]}))}}else{throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)")}t=t.length>0?t.map((([e,t])=>{v(e);W(e,String(t));return[String(e).toLowerCase(),String(t)]})):undefined;super(t);return new Proxy(this,{get(e,t,r){switch(t){case"append":case"set":return(r,n)=>{v(r);W(r,String(n));return URLSearchParams.prototype[t].call(e,String(r).toLowerCase(),String(n))};case"delete":case"has":case"getAll":return r=>{v(r);return URLSearchParams.prototype[t].call(e,String(r).toLowerCase())};case"keys":return()=>{e.sort();return new Set(URLSearchParams.prototype.keys.call(e)).keys()};default:return Reflect.get(e,t,r)}}})}get[Symbol.toStringTag](){return this.constructor.name}toString(){return Object.prototype.toString.call(this)}get(e){const t=this.getAll(e);if(t.length===0){return null}let r=t.join(", ");if(/^content-encoding$/i.test(e)){r=r.toLowerCase()}return r}forEach(e,t=undefined){for(const r of this.keys()){Reflect.apply(e,t,[this.get(r),r,this])}}*values(){for(const e of this.keys()){yield this.get(e)}}*entries(){for(const e of this.keys()){yield[e,this.get(e)]}}[Symbol.iterator](){return this.entries()}raw(){return[...this.keys()].reduce(((e,t)=>{e[t]=this.getAll(t);return e}),{})}[Symbol.for("nodejs.util.inspect.custom")](){return[...this.keys()].reduce(((e,t)=>{const r=this.getAll(t);if(t==="host"){e[t]=r[0]}else{e[t]=r.length>1?r:r[0]}return e}),{})}}Object.defineProperties(Headers.prototype,["get","entries","forEach","values"].reduce(((e,t)=>{e[t]={enumerable:true};return e}),{}));function fromRawHeaders(e=[]){return new Headers(e.reduce(((e,t,r,n)=>{if(r%2===0){e.push(n.slice(r,r+2))}return e}),[]).filter((([e,t])=>{try{v(e);W(e,String(t));return true}catch{return false}})))}const E=new Set([301,302,303,307,308]);const isRedirect=e=>E.has(e);const P=Symbol("Response internals");class Response extends Body{constructor(e=null,t={}){super(e,t);const r=t.status!=null?t.status:200;const n=new Headers(t.headers);if(e!==null&&!n.has("Content-Type")){const t=extractContentType(e);if(t){n.append("Content-Type",t)}}this[P]={type:"default",url:t.url,status:r,statusText:t.statusText||"",headers:n,counter:t.counter,highWaterMark:t.highWaterMark}}get type(){return this[P].type}get url(){return this[P].url||""}get status(){return this[P].status}get ok(){return this[P].status>=200&&this[P].status<300}get redirected(){return this[P].counter>0}get statusText(){return this[P].statusText}get headers(){return this[P].headers}get highWaterMark(){return this[P].highWaterMark}clone(){return new Response(clone(this,this.highWaterMark),{type:this.type,url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected,size:this.size})}static redirect(e,t=302){if(!isRedirect(t)){throw new RangeError('Failed to execute "redirect" on "response": Invalid status code')}return new Response(null,{headers:{location:new URL(e).toString()},status:t})}static error(){const e=new Response(null,{status:0,statusText:""});e[P].type="error";return e}get[Symbol.toStringTag](){return"Response"}}Object.defineProperties(Response.prototype,{type:{enumerable:true},url:{enumerable:true},status:{enumerable:true},ok:{enumerable:true},redirected:{enumerable:true},statusText:{enumerable:true},headers:{enumerable:true},clone:{enumerable:true}});const B=require("url");const getSearch=e=>{if(e.search){return e.search}const t=e.href.length-1;const r=e.hash||(e.href[t]==="#"?"#":"");return e.href[t-r.length]==="?"?"?":""};const T=Symbol("Request internals");const isRequest=e=>typeof e==="object"&&typeof e[T]==="object";class Request extends Body{constructor(e,t={}){let r;if(isRequest(e)){r=new URL(e.url)}else{r=new URL(e);e={}}let n=t.method||e.method||"GET";n=n.toUpperCase();if((t.body!=null||isRequest(e))&&e.body!==null&&(n==="GET"||n==="HEAD")){throw new TypeError("Request with GET/HEAD method cannot have body")}const o=t.body?t.body:isRequest(e)&&e.body!==null?clone(e):null;super(o,{size:t.size||e.size||0});const a=new Headers(t.headers||e.headers||{});if(o!==null&&!a.has("Content-Type")){const e=extractContentType(o,this);if(e){a.append("Content-Type",e)}}let i=isRequest(e)?e.signal:null;if("signal"in t){i=t.signal}if(i!=null&&!isAbortSignal(i)){throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget")}this[T]={method:n,redirect:t.redirect||e.redirect||"follow",headers:a,parsedURL:r,signal:i};this.follow=t.follow===undefined?e.follow===undefined?20:e.follow:t.follow;this.compress=t.compress===undefined?e.compress===undefined?true:e.compress:t.compress;this.counter=t.counter||e.counter||0;this.agent=t.agent||e.agent;this.highWaterMark=t.highWaterMark||e.highWaterMark||16384;this.insecureHTTPParser=t.insecureHTTPParser||e.insecureHTTPParser||false}get method(){return this[T].method}get url(){return(0,B.format)(this[T].parsedURL)}get headers(){return this[T].headers}get redirect(){return this[T].redirect}get signal(){return this[T].signal}clone(){return new Request(this)}get[Symbol.toStringTag](){return"Request"}}Object.defineProperties(Request.prototype,{method:{enumerable:true},url:{enumerable:true},headers:{enumerable:true},redirect:{enumerable:true},clone:{enumerable:true},signal:{enumerable:true}});const getNodeRequestOptions=e=>{const{parsedURL:t}=e[T];const r=new Headers(e[T].headers);if(!r.has("Accept")){r.set("Accept","*/*")}let n=null;if(e.body===null&&/^(post|put)$/i.test(e.method)){n="0"}if(e.body!==null){const t=getTotalBytes(e);if(typeof t==="number"&&!Number.isNaN(t)){n=String(t)}}if(n){r.set("Content-Length",n)}if(!r.has("User-Agent")){r.set("User-Agent","node-fetch")}if(e.compress&&!r.has("Accept-Encoding")){r.set("Accept-Encoding","gzip,deflate,br")}let{agent:o}=e;if(typeof o==="function"){o=o(t)}if(!r.has("Connection")&&!o){r.set("Connection","close")}const a=getSearch(t);const i={path:t.pathname+a,pathname:t.pathname,hostname:t.hostname,protocol:t.protocol,port:t.port,hash:t.hash,search:t.search,query:t.query,href:t.href,method:e.method,headers:r[Symbol.for("nodejs.util.inspect.custom")](),insecureHTTPParser:e.insecureHTTPParser,agent:o};return i};class AbortError extends FetchBaseError{constructor(e,t="aborted"){super(e,t)}}const I=new Set(["data:","http:","https:"]);async function fetch(e,t){return new Promise(((r,n)=>{const o=new Request(e,t);const a=getNodeRequestOptions(o);if(!I.has(a.protocol)){throw new TypeError(`node-fetch cannot load ${e}. URL scheme "${a.protocol.replace(/:$/,"")}" is not supported.`)}if(a.protocol==="data:"){const e=d(o.url);const t=new Response(e,{headers:{"Content-Type":e.typeFull}});r(t);return}const c=(a.protocol==="https:"?l:i).request;const{signal:f}=o;let m=null;const abort=()=>{const e=new AbortError("The operation was aborted.");n(e);if(o.body&&o.body instanceof u.Readable){o.body.destroy(e)}if(!m||!m.body){return}m.body.emit("error",e)};if(f&&f.aborted){abort();return}const abortAndFinalize=()=>{abort();finalize()};const h=c(a);if(f){f.addEventListener("abort",abortAndFinalize)}const finalize=()=>{h.abort();if(f){f.removeEventListener("abort",abortAndFinalize)}};h.on("error",(e=>{n(new FetchError(`request to ${o.url} failed, reason: ${e.message}`,"system",e));finalize()}));fixResponseChunkedTransferBadEnding(h,(e=>{m.body.destroy(e)}));if(process.version<"v14"){h.on("socket",(e=>{let t;e.prependListener("end",(()=>{t=e._eventsCount}));e.prependListener("close",(r=>{if(m&&t<e._eventsCount&&!r){const e=new Error("Premature close");e.code="ERR_STREAM_PREMATURE_CLOSE";m.body.emit("error",e)}}))}))}h.on("response",(e=>{h.setTimeout(0);const a=fromRawHeaders(e.rawHeaders);if(isRedirect(e.statusCode)){const i=a.get("Location");const l=i===null?null:new URL(i,o.url);switch(o.redirect){case"error":n(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${o.url}`,"no-redirect"));finalize();return;case"manual":if(l!==null){a.set("Location",l)}break;case"follow":{if(l===null){break}if(o.counter>=o.follow){n(new FetchError(`maximum redirect reached at: ${o.url}`,"max-redirect"));finalize();return}const a={headers:new Headers(o.headers),follow:o.follow,counter:o.counter+1,agent:o.agent,compress:o.compress,method:o.method,body:o.body,signal:o.signal,size:o.size};if(e.statusCode!==303&&o.body&&t.body instanceof u.Readable){n(new FetchError("Cannot follow redirect with body being a readable stream","unsupported-redirect"));finalize();return}if(e.statusCode===303||(e.statusCode===301||e.statusCode===302)&&o.method==="POST"){a.method="GET";a.body=undefined;a.headers.delete("content-length")}r(fetch(new Request(l,a)));finalize();return}default:return n(new TypeError(`Redirect option '${o.redirect}' is not a valid value of RequestRedirect`))}}if(f){e.once("end",(()=>{f.removeEventListener("abort",abortAndFinalize)}))}let i=(0,u.pipeline)(e,new u.PassThrough,n);if(process.version<"v12.10"){e.on("aborted",abortAndFinalize)}const l={url:o.url,status:e.statusCode,statusText:e.statusMessage,headers:a,size:o.size,counter:o.counter,highWaterMark:o.highWaterMark};const d=a.get("Content-Encoding");if(!o.compress||o.method==="HEAD"||d===null||e.statusCode===204||e.statusCode===304){m=new Response(i,l);r(m);return}const c={flush:s.Z_SYNC_FLUSH,finishFlush:s.Z_SYNC_FLUSH};if(d==="gzip"||d==="x-gzip"){i=(0,u.pipeline)(i,s.createGunzip(c),n);m=new Response(i,l);r(m);return}if(d==="deflate"||d==="x-deflate"){const t=(0,u.pipeline)(e,new u.PassThrough,n);t.once("data",(e=>{i=(e[0]&15)===8?(0,u.pipeline)(i,s.createInflate(),n):(0,u.pipeline)(i,s.createInflateRaw(),n);m=new Response(i,l);r(m)}));return}if(d==="br"){i=(0,u.pipeline)(i,s.createBrotliDecompress(),n);m=new Response(i,l);r(m);return}m=new Response(i,l);r(m)}));writeToStream(h,o)}))}function fixResponseChunkedTransferBadEnding(e,t){const r=Buffer.from("0\r\n\r\n");let n=false;let o=false;let a;e.on("response",(e=>{const{headers:t}=e;n=t["transfer-encoding"]==="chunked"&&!t["content-length"]}));e.on("socket",(i=>{const onSocketClose=()=>{if(n&&!o){const e=new Error("Premature close");e.code="ERR_STREAM_PREMATURE_CLOSE";t(e)}};i.prependListener("close",onSocketClose);e.on("abort",(()=>{i.removeListener("close",onSocketClose)}));i.on("data",(e=>{o=Buffer.compare(e.slice(-5),r)===0;if(!o&&a){o=Buffer.compare(a.slice(-3),r.slice(0,3))===0&&Buffer.compare(e.slice(-2),r.slice(3))===0}a=e}))}))}var k=undefined&&undefined.__awaiter||function(e,t,r,n){function adopt(e){return e instanceof r?e:new r((function(t){t(e)}))}return new(r||(r=Promise))((function(r,o){function fulfilled(e){try{step(n.next(e))}catch(e){o(e)}}function rejected(e){try{step(n["throw"](e))}catch(e){o(e)}}function step(e){e.done?r(e.value):adopt(e.value).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())}))};const D=f().promisify(__nccwpck_require__(413).pipeline);function unzip(e,t,o){const a=r.join(o,`sde-temp-files`);return new Promise(((r,i)=>{n.unpack(e,o,(e=>{if(e){i(e);return}n.unpack(t,a,(e=>{if(e){i(e);return}r(a)}))}))}))}function getPlatformIdentifier(){switch(process.platform){case"win32":return`win`;case"darwin":return`mac`;case"linux":return`lin`;default:throw new Error(`Platform '${process.platform}' is not supported in this context.`)}}function run(){return k(this,void 0,void 0,(function*(){try{const n=t.getInput("environmentVariableName")||"SDE_PATH";if(!n||n.length<=0){t.setFailed("Missing environment variable name input variable.");return}const o=t.getInput("sdeVersion")||process.argv[2];if(!o||o.length<=0){t.setFailed("Missing SDE version input variable.");return}t.info(`environmentVariableName: ${n}`);t.info(`sdeVersion: ${o}`);const i=getPlatformIdentifier();const l=`https://software.intel.com/content/dam/develop/external/us/en/documents/downloads/sde-external-${o}-${i}.tar.bz2`;const s=r.resolve(`.output`);const u=r.join(s,`sde-temp-file.tar.bz2`);const d=r.join(s,`sde-temp-file.tar`);const c=r.join(s,`sde-temp-files`);a().mkdir(s,{recursive:true},(e=>{if(e)throw e}));const f=yield fetch(l);if(!f.ok){throw new Error(`unexpected response ${f.statusText}`)}yield D(f.body,a().createWriteStream(u));if(process.platform!="win32"){yield e.exec(`sudo chmod`,["-R","777",__dirname]);yield e.exec(`sudo chmod`,["-R","777",s])}let m;if(process.platform!="win32"){m=r.join(s,`sde-temp-files`);a().mkdir(m,{recursive:true},(e=>{if(e)throw e}));yield e.exec(`tar`,["xvf",u,"-C",m])}else{m=yield unzip(u,d,s)}const h=a().readdirSync(m);if(h&&h.length===1){if(process.platform!="win32"){yield e.exec(`sudo chmod`,["-R","777",s])}const o=r.join(c,h[0]);t.exportVariable(n,o)}else{t.setFailed(`Failed to get SDE path.`)}}catch(e){t.setFailed(`An error has occurred while setuping SDE binaries.`);t.error(e)}}))}run()})();module.exports=__webpack_exports__})();